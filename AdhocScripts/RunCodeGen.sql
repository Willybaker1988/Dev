/*
Deployment script for Transform

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DATA_WAREHOUSE_DATABASE_NAME "DataWarehouse"
:setvar DATA_WAREHOUSE_DIFRAMEWORK_DATABASE_NAME "DIFramework"
:setvar master "master"
:setvar DatabaseName "Transform"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/


PRINT	'######## ########     ###    ##    ##  ######  ########  #######  ########  ##     ##'; 
PRINT	'   ##    ##     ##   ## ##   ###   ## ##    ## ##       ##     ## ##     ## ###   ###'; 
PRINT	'   ##    ##     ##  ##   ##  ####  ## ##       ##       ##     ## ##     ## #### ####'; 
PRINT	'   ##    ########  ##     ## ## ## ##  ######  ######   ##     ## ########  ## ### ##'; 
PRINT	'   ##    ##   ##   ######### ##  ####       ## ##       ##     ## ##   ##   ##     ##'; 
PRINT	'   ##    ##    ##  ##     ## ##   ### ##    ## ##       ##     ## ##    ##  ##     ##'; 
PRINT	'   ##    ##     ## ##     ## ##    ##  ######  ##        #######  ##     ## ##     ##'; 

PRINT 'Deploying to ' + DB_NAME(DB_ID()) + ' on ' + @@SERVERNAME;

/* Add References to your Pre-Deployment scripts here. No T-SQL in this file, please. */

GO

GO
:setvar ExecDynamicSQL "1"
:setvar PrintDynamicSQL "1"
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

PRINT 'Deploying to ' + DB_NAME(DB_ID()) + ' on ' + @@SERVERNAME;

/* Add References to your Pre-Deployment scripts here. No T-SQL in this file, please. */

DECLARE	@vCodeGenerationStartTime	DATETIME2	=	SYSDATETIME()
,		@vCodeGenerationEndTime		DATETIME2						;

/*Table info*/
DECLARE	@vTableName								SYSNAME
,		@vTableSchemaName						SYSNAME		
,		@vNKeyColumnName						SYSNAME		
,		@vSKeyColumnName						SYSNAME		
,		@vSKeyColumnType						SYSNAME
,		@vGenerateToTransformFlag				BIT
,		@vGenerateCopyToMirrorFlag				BIT
,		@vGenerateToMirrorFlag					BIT
,		@vGeneratePublishFlag					BIT
,		@vHasGeneratedValues					BIT
,		@vHasType2AttributeFlag					BIT											;
/*Column info*/
DECLARE	@vColumnName							SYSNAME
,		@vColumnType							SYSNAME		
,		@vColumnMaxLength						INT			
,		@vColumnPrecision						INT			
,		@vColumnScale							INT			
,		@vColumnIsNullable						BIT											
,		@vColumnName2							SYSNAME										;
/*Used in code gen*/
DECLARE	@vProcedureName									SYSNAME
,		@vProcedureSchemaName							SYSNAME
,		@vProcedureBody									NVARCHAR(MAX)
,		@vLookup										NVARCHAR(MAX)	
,		@vProcedureSchemaAndProcedureName				NVARCHAR(MAX)	
,		@vFunctionSchemaAndFunctionName					NVARCHAR(MAX)			
,		@vTablePrefix									SYSNAME
,		@vViewPrefix									SYSNAME
,		@vViewSuffix									SYSNAME
,		@vMirrorTablePrefix								SYSNAME
,		@vTransformTablePrefix							SYSNAME
,		@vProcedurePrefix								SYSNAME
,		@vFunctionPrefix								SYSNAME
,		@vCurrentRecordSubQuery							NVARCHAR(MAX)										
,		@vSQL											NVARCHAR(MAX)
,		@vColumnDDL										NVARCHAR(MAX)
,		@vReferencedColumnDDL							NVARCHAR(MAX)
,		@vLookupColumnDDL								NVARCHAR(MAX)
,		@vReferencedTableName							SYSNAME
,		@vReferencedTableSchemaName						SYSNAME
,		@vReferencedColumnName							SYSNAME
,		@vReferencedTableNKeyColumnName					SYSNAME
,		@vLookupColumnName								SYSNAME
,		@vInsertColumnDML								NVARCHAR(MAX)
,		@vInsertColumn2DML								NVARCHAR(MAX)
,		@vValuesColumnDML								NVARCHAR(MAX)
,		@vSelectColumnDML								NVARCHAR(MAX)
,		@vSelectColumn2DML								NVARCHAR(MAX)
,		@vUpdateColumnDML								NVARCHAR(MAX)
,		@vNKeyJoinColumnDML								NVARCHAR(MAX)
,		@vNKeySelectColumnDML							NVARCHAR(MAX)
,		@vLookupColumnDML								NVARCHAR(MAX)
,		@vMergeType2UpdateConditionColumnDML			NVARCHAR(MAX)
--,		@vMergeType2UpdateSetColumnDML					NVARCHAR(MAX)
,		@vMergeType2OutputColumnDML						NVARCHAR(MAX)
,		@vMergeType1UpdateConditionColumnDML			NVARCHAR(MAX)
,		@vMergeType1UpdateSetColumnDML					NVARCHAR(MAX)
,		@vReferencedTableNKeyColumnDML					NVARCHAR(MAX)
,		@vUnknownValue									NVARCHAR(MAX)
,		@vReferencedColumnUnknownValue					NVARCHAR(MAX)
,		@vColumnsDDL									NVARCHAR(MAX)
,		@vInsertColumnsDML								NVARCHAR(MAX)
,		@vInsertColumns2DML								NVARCHAR(MAX)
,		@vValuesColumnsDML								NVARCHAR(MAX)
,		@vSelectColumnsDML								NVARCHAR(MAX)
,		@vSelectColumns2DML								NVARCHAR(MAX)
,		@vUpdateColumnsDML								NVARCHAR(MAX)
,		@vNKeyJoinColumnsDML							NVARCHAR(MAX)
,		@vNKeyJoinColumns2DML							NVARCHAR(MAX)
,		@vNKeySelectColumnsDML							NVARCHAR(MAX)
,		@vMergeType2UpdateConditionColumnsDML			NVARCHAR(MAX)
--,		@vMergeType2UpdateSetColumnsDML						NVARCHAR(MAX)
,		@vMergeType2OutputColumnsDML					NVARCHAR(MAX)
,		@vMergeType1UpdateConditionColumnsDML			NVARCHAR(MAX)
,		@vMergeType1UpdateSetColumnsDML					NVARCHAR(MAX)
,		@vWhenMatchedClause								NVARCHAR(MAX)
,		@vLookupUpdateQuery								NVARCHAR(MAX)
,		@vInferredMemberCreation						NVARCHAR(MAX)
,		@vLoopCounter									INT			
,		@vRemark										VARCHAR(MAX)
,		@vObjectToBeGenerated							NVARCHAR(256)
,		@vPartitionKeyColumnName						SYSNAME
,		@vPartitionKeyColumnTypeDefinition				SYSNAME
,		@vReferencedTableHasGeneratedValues				BIT
,		@vReferencedTableCanHaveInferredMembersCreated	BIT
,       @vFirstNKeyJoinColumn                           SYSNAME
,       @vPartitionFunctionName                         SYSNAME
,       @vPartitionSchemeName                           SYSNAME
,       @vUnionDefinition                               NVARCHAR(MAX);
/*Constants*/
DECLARE	@vGlobalProcedurePrefix					SYSNAME			=	N'usp'					
,		@vGlobalFunctionPrefix					SYSNAME			=	N'udf'					
,		@vGlobalViewPrefix						SYSNAME			=	N'vw'					
,		@vGlobalPrimaryKeyPrefix				SYSNAME			=	N'pk'					
,		@vGlobalUniqueKeyPrefix					SYSNAME			=	N'unq'					
,		@vGlobalCurrentViewSuffix				SYSNAME			=	N'Current'
,		@vSwitchInSuffix						SYSNAME			=	N'SwitchIn'				
,		@vSwitchOutSuffix						SYSNAME			=	N'SwitchOut'				
--,		@vWarehouseTableTypeExPropName			SYSNAME			=	N'WarehouseTableType'	
--,		@vDoCodeGenerationFlagExPropName		SYSNAME			=	N'DoCodeGenerationFlag'	
--,		@vDimensionTableExPropValue				SYSNAME			=	N'Dimension'			
--,		@vDoCodeGenerationExPropValue			SYSNAME			=	N'1'					
,		@vIndent								NVARCHAR(MAX)	=	N'    '					
,		@vPublishTypeIgnore						SYSNAME			=	N'0'						
,		@vPublishTypeInsert						SYSNAME			=	N'1'						
,		@vPublishTypeUpdate						SYSNAME			=	N'2'						
,		@vPublishTypeDelete						SYSNAME			=	N'3'						
,		@vCreatedByColumnName					SYSNAME			=	N'CreatedByLogID'			
,		@vLastModifiedByColumnName				SYSNAME			=	N'LastModifiedByLogID'	
,		@vLineageIDParameterName				SYSNAME			=	N'@pLogID';

PRINT	REPLACE(N'Code generation started at @vCodeGenerationStartTime',N'@vCodeGenerationStartTime',@vCodeGenerationStartTime);
--DECLARE	dim_tables_with_no_defined_SK_cursor CURSOR
--FOR		SELECT	[TableName],[TableSchemaName]
--		FROM	codegeneration.udfDataWarehouseTableMetadata(DEFAULT,DEFAULT,N'Dimension',DEFAULT)
--		WHERE	[SurrogateKeyFieldName] IS NULL

		
--OPEN dim_tables_with_no_defined_SK_cursor;
--FETCH NEXT FROM dim_tables_with_no_defined_SK_cursor INTO @vTableName,@vTableSchemaName;

--WHILE @@FETCH_STATUS = 0
--BEGIN
--		RAISERROR('Table [%s].[%s] has no surrogate key defined',16,1,@vTableSchemaName,@vTableName);
--		FETCH NEXT FROM dim_tables_with_no_defined_SK_cursor INTO @vTableName,@vTableSchemaName;
--END

--CLOSE	dim_tables_with_no_defined_SK_cursor;
--DEALLOCATE	dim_tables_with_no_defined_SK_cursor;

--DECLARE	dim_tables_with_no_defined_NK_cursor CURSOR
--FOR		SELECT	[TableName],[TableSchemaName]
--		FROM	codegeneration.udfDataWarehouseTableMetadata(DEFAULT,DEFAULT,N'Dimension',DEFAULT)
--		WHERE	[NaturalKeyFieldName] IS NULL

		
--OPEN dim_tables_with_no_defined_NK_cursor;
--FETCH NEXT FROM dim_tables_with_no_defined_NK_cursor INTO @vTableName,@vTableSchemaName;

--WHILE @@FETCH_STATUS = 0
--BEGIN
--		RAISERROR('Table [%s].[%s] has no natural key defined',16,1,@vTableSchemaName,@vTableName);
--		FETCH NEXT FROM dim_tables_with_no_defined_NK_cursor INTO @vTableName,@vTableSchemaName;
--END

--CLOSE	dim_tables_with_no_defined_NK_cursor;
--DEALLOCATE	dim_tables_with_no_defined_NK_cursor;

--DECLARE	tables_have_a_defined_table_type_cursor CURSOR
--FOR		SELECT	[TableName],[TableSchemaName]
--		FROM	codegeneration.udfDataWarehouseTableMetadata(DEFAULT,DEFAULT,DEFAULT,DEFAULT)
--		WHERE	[WarehouseTableType] IS NULL

		
--OPEN tables_have_a_defined_table_type_cursor;
--FETCH NEXT FROM tables_have_a_defined_table_type_cursor INTO @vTableName,@vTableSchemaName;

--WHILE @@FETCH_STATUS = 0
--BEGIN
--		RAISERROR('Table [%s].[%s] has no value set for extended property %s. This is required for code generation purposes',16,1,@vTableSchemaName,@vTableName,'WarehouseTableType');
--		FETCH NEXT FROM tables_have_a_defined_table_type_cursor INTO @vTableName,@vTableSchemaName;
--END

--CLOSE	tables_have_a_defined_table_type_cursor;
--DEALLOCATE	tables_have_a_defined_table_type_cursor;
--DECLARE	dim_tables_with_no_defined_SCDValidFrom_cursor CURSOR
--FOR		SELECT	t.[TableName],t.[TableSchemaName]
--		FROM	(
--				SELECT	t.[TableName],t.[TableSchemaName]
--				FROM	codegeneration.udfDataWarehouseTableMetadata(DEFAULT,DEFAULT,N'Dimension',DEFAULT)t
--				WHERE	t.[DoETL] = 1
--				)t
--		LEFT OUTER JOIN (
--				SELECT	c.[TableName],c.[TableSchemaName],c.[ColumnName]
--				FROM	codegeneration.[udfDataWarehouseTableColumnMetadata](DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT)c
--				WHERE	c.[ColumnName] = N'SCDValidFrom'
--				)c
--			ON	t.[TableName]		=	c.[TableName]
--			AND	t.[TableSchemaName]	=	c.[TableSchemaName]
--		WHERE	c.[ColumnName] IS NULL;

		
--OPEN dim_tables_with_no_defined_SCDValidFrom_cursor;
--FETCH NEXT FROM dim_tables_with_no_defined_SCDValidFrom_cursor INTO @vTableName,@vTableSchemaName;

--WHILE @@FETCH_STATUS = 0
--BEGIN
--		RAISERROR('Table [%s].[%s] has no SCDValidFrom column',16,1,@vTableSchemaName,@vTableName);
--		FETCH NEXT FROM dim_tables_with_no_defined_SK_cursor INTO @vTableName,@vTableSchemaName;
--END

--CLOSE	dim_tables_with_no_defined_SCDValidFrom_cursor;
--DEALLOCATE	dim_tables_with_no_defined_SCDValidFrom_cursor;

--DECLARE	dim_tables_with_no_defined_SCDValidTo_cursor CURSOR
--FOR		SELECT	t.[TableName],t.[TableSchemaName]
--		FROM	(
--				SELECT	t.[TableName],t.[TableSchemaName]
--				FROM	codegeneration.udfDataWarehouseTableMetadata(DEFAULT,DEFAULT,N'Dimension',DEFAULT)t
--				WHERE	t.[DoETL] = 1
--				)t
--		LEFT OUTER JOIN (
--				SELECT	c.[TableName],c.[TableSchemaName],c.[ColumnName]
--				FROM	codegeneration.[udfDataWarehouseTableColumnMetadata](DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT)c
--				WHERE	c.[ColumnName] = N'SCDValidTo'
--				)c
--			ON	t.[TableName]		=	c.[TableName]
--			AND	t.[TableSchemaName]	=	c.[TableSchemaName]
--		WHERE	c.[ColumnName] IS NULL;

		
--OPEN dim_tables_with_no_defined_SCDValidTo_cursor;
--FETCH NEXT FROM dim_tables_with_no_defined_SCDValidTo_cursor INTO @vTableName,@vTableSchemaName;

--WHILE @@FETCH_STATUS = 0
--BEGIN
--		RAISERROR('Table [%s].[%s] has no SCDValidTO column',16,1,@vTableSchemaName,@vTableName);
--		FETCH NEXT FROM dim_tables_with_no_defined_SCDValidTo_cursor INTO @vTableName,@vTableSchemaName;
--END

--CLOSE	dim_tables_with_no_defined_SCDValidTo_cursor;
--DEALLOCATE	dim_tables_with_no_defined_SCDValidTo_cursor;

--DECLARE	dim_tables_with_no_defined_IsCurrent_cursor CURSOR
--FOR		SELECT	t.[TableName],t.[TableSchemaName]
--		FROM	(
--				SELECT	t.[TableName],t.[TableSchemaName]
--				FROM	codegeneration.udfDataWarehouseTableMetadata(DEFAULT,DEFAULT,N'Dimension',DEFAULT)t
--				WHERE	t.[DoETL] = 1
--				)t
--		LEFT OUTER JOIN (
--				SELECT	c.[TableName],c.[TableSchemaName],c.[ColumnName]
--				FROM	codegeneration.[udfDataWarehouseTableColumnMetadata](DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT)c
--				WHERE	c.[ColumnName] = N'IsCurrent'
--				)c
--			ON	t.[TableName]		=	c.[TableName]
--			AND	t.[TableSchemaName]	=	c.[TableSchemaName]
--		WHERE	c.[ColumnName] IS NULL;

		
--OPEN dim_tables_with_no_defined_IsCurrent_cursor;
--FETCH NEXT FROM dim_tables_with_no_defined_IsCurrent_cursor INTO @vTableName,@vTableSchemaName;

--WHILE @@FETCH_STATUS = 0
--BEGIN
--		RAISERROR('Table [%s].[%s] has no IsCurrent column',16,1,@vTableSchemaName,@vTableName);
--		FETCH NEXT FROM dim_tables_with_no_defined_IsCurrent_cursor INTO @vTableName,@vTableSchemaName;
--END

--CLOSE	dim_tables_with_no_defined_IsCurrent_cursor;
--DEALLOCATE	dim_tables_with_no_defined_IsCurrent_cursor;
--IF EXISTS (
--		SELECT	[object_id],Tally=COUNT(*)
--		FROM	[datawarehouse].[udfPartitionColumn]()
--		GROUP	BY [object_id]
--		HAVING	COUNT(*) > 1
--		)
--	RAISERROR('At least one table exists with more than one column in the aprtition key. This code geenration framework does not currently allow for this! Sorry!',16,1);
--DECLARE	degenerate_dimensions_with_different_defined_unknown_value_cursor CURSOR
--FOR		SELECT  [ColumnName]
--        FROM    (
--                SELECT	c.[ColumnName],c.[UnknownValue],c.[UnknownValueDML],[Rank]=RANK()OVER(PARTITION BY c.[ColumnName] ORDER BY c.[UnknownValue])
--                FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT)c
--                INNER JOIN [codegeneration].[udfDataWarehouseTableMetadata](DEFAULT,DEFAULT,'Fact',DEFAULT)t
--                    ON  t.[object_id] = c.[object_id]
--                WHERE	c.[DegenerateDimension] = 1
--                )q
--        WHERE   [Rank] > 1;
		
--OPEN degenerate_dimensions_with_different_defined_unknown_value_cursor;
--FETCH NEXT FROM degenerate_dimensions_with_different_defined_unknown_value_cursor INTO @vColumnName;

--WHILE @@FETCH_STATUS = 0
--BEGIN
--		RAISERROR('Multiple unknown values have been specified for degenerate dimension [%s]. There can only be one',16,1,@vColumnName);
--		FETCH NEXT FROM degenerate_dimensions_with_different_defined_unknown_value_cursor INTO @vColumnName;
--END

--CLOSE degenerate_dimensions_with_different_defined_unknown_value_cursor;
--DEALLOCATE degenerate_dimensions_with_different_defined_unknown_value_cursor;
--USE Transform
--DECLARE @vTableNameWithNoType2AttributeFlagsButUniqueConstraintIncludesSCDValidFrom SYSNAME;
--SELECT  @vTableNameWithNoType2AttributeFlagsButUniqueConstraintIncludesSCDValidFrom = MAX(tc.[TableName])
--FROM    [codegeneration].[udfDataWarehouseTableConstraintMetadata](DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT) tc
--INNER JOIN [codegeneration].[udfDataWarehouseTableMetadata](DEFAULT,DEFAULT,DEFAULT,DEFAULT) t
--    ON  t.[TableName] = tc.[TableName]
--    AND t.[TableSchemaName] = tc.[TableSchemaName]
--WHERE   tc.[MirrorCols] LIKE '%SCDValidFrom%'
--    AND t.[HasType2AttributeFlag] = 0
--IF  @vTableNameWithNoType2AttributeFlagsButUniqueConstraintIncludesSCDValidFrom IS NOT NULL
--BEGIN
--    RAISERROR(N'Table ''%s'' has no type2 attributes thus should not have SCDValidFrom as part of a unique constraint',16,1,@vTableNameWithNoType2AttributeFlagsButUniqueConstraintIncludesSCDValidFrom)
--END
--IF EXISTS (
--        SELECT  p.[PartitionSchemeName]
--        FROM    (
--		        SELECT	p.[TableSchemaName],p.[PartitionSchemeName]
--		        FROM	[codegeneration].[udfDataWarehousePartitionedTableMetadata]()p
--                GROUP   BY p.[TableSchemaName],p.[PartitionSchemeName]
--                )p
--		GROUP	BY p.[PartitionSchemeName]
--		HAVING	COUNT(*) > 1
--		)
--	RAISERROR('Technically there''s nothing wrong with having tables in different schemas using the same partition function/scheme, but we''re disallowing it for reasons of neatness (and my OCD tendencies :) )',16,1);
--DECLARE @naturalKeysNaturalKeyTableName     SYSNAME
--,       @naturalKeysNaturalKeyColumnName    SYSNAME
--,       @naturalKeysConstraintTableName     SYSNAME
--,       @naturalKeysConstraintColumnName    SYSNAME
--;

--DECLARE naturalKeys CURSOR FOR
--        SELECT  NaturalKeyTableName=nk.TableName
--        ,       NaturalKeyColumnName=nk.ColumnName
--        ,       ConstraintTableName=c.TableName
--        ,       ConstraintColumnName=c.ColumnName
--        FROM    (
--                select TableName,ColumnName from [codegeneration].[udfDataWarehouseTableColumnMetadata](default,default,default,default,default,default)
--                where IsNaturalKey =1
--                )nk
--        FULL OUTER JOIN (
--                select constraints.[TableName],ColumnName=c.[name] from [codegeneration].udfDataWarehouseTableConstraintMetadata(DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT)constraints
--                INNER JOIN [codegeneration].[udfDataWarehouseTableMetadata](DEFAULT,DEFAULT,DEFAULT,DEFAULT) t ON constraints.[TableSchemaName] = t.[TableSchemaName] AND constraints.[TableName] = t.[TableName]
--                INNER JOIN DataWarehouse.sys.indexes i on constraints.ConstraintName = i.name
--                INNER JOIN DataWarehouse.sys.index_columns ic on i.object_id = ic.object_id and i.index_id = ic.index_id
--                INNER JOIN DataWarehouse.sys.columns c on ic.object_id = c.object_id and ic.column_id = c.column_id
--                WHERE TransformConstraintDDL IS NOT NULL
--                    AND t.[WarehouseTableType] = N'Dimension'
--                )c
--            ON  nk.[TableName] = c.[TableName]
--            AND nk.[ColumnName] = c.[ColumnName]
--        WHERE   nk.[ColumnName] IS NULL
--            OR  c.[ColumnName] IS NULL
--        ORDER BY ISNULL(nk.TableName,c.TableName)

--OPEN naturalKeys;
--FETCH NEXT FROM naturalKeys INTO @naturalKeysNaturalKeyTableName,@naturalKeysNaturalKeyColumnName,@naturalKeysConstraintTableName,@naturalKeysConstraintColumnName;
--WHILE @@FETCH_STATUS = 0
--BEGIN
--        SET @naturalKeysNaturalKeyTableName = ISNULL(@naturalKeysNaturalKeyTableName,@naturalKeysConstraintTableName);
--        RAISERROR('Natural key definition does not match unique key definition on dimension table %s',16,1,@naturalKeysNaturalKeyTableName);
--        FETCH NEXT FROM naturalKeys INTO @naturalKeysNaturalKeyTableName,@naturalKeysNaturalKeyColumnName,@naturalKeysConstraintTableName,@naturalKeysConstraintColumnName;
--END

--CLOSE naturalKeys;
--DEALLOCATE naturalKeys;


/*Get a list of all all the dimension tables for which we are going to generate transformation objects*/
DECLARE	dimension_table_cursor CURSOR
FOR		SELECT	t.[TableName],t.[TableSchemaName],t.[NaturalKeyFieldName],t.[GenerateToTransformFlag],t.[SurrogateKeyFieldName],t.[SurrogateKeyFieldType],t.[HasType2AttributeFlag],t.[HasGeneratedValues],t.[GenerateCopyToMirrorFlag],t.[GenerateToMirrorFlag],t.[GeneratePublishFlag]
		FROM	[codegeneration].[udfDataWarehouseTableMetadata](DEFAULT,DEFAULT,N'Dimension',N'1')t
		WHERE	t.[DoETL] = 1;
		
OPEN dimension_table_cursor;
FETCH NEXT FROM dimension_table_cursor INTO @vTableName,@vTableSchemaName,@vNKeyColumnName,@vGenerateToTransformFlag,@vSKeyColumnName,@vSKeyColumnType,@vHasType2AttributeFlag,@vHasGeneratedValues,@vGenerateCopyToMirrorFlag,@vGenerateToMirrorFlag,@vGeneratePublishFlag;

WHILE @@FETCH_STATUS = 0
BEGIN
		PRINT	REPLACE(REPLACE(N'Generating ETL objects for [@vTableSchemaName].[@vTableName]','@vTableSchemaName',@vTableSchemaName),N'@vTableName',@vTableName);
		SET	@vTablePrefix =	N'Mirror';
		SET	@vLoopCounter = 0;
		SET	@vSQL = N'IF EXISTS (SELECT 1 FROM [sys].[tables] WHERE [name] = N''@vTablePrefix@vTableName'' AND SCHEMA_NAME([schema_id]) = N''@vTableSchemaName'') DROP TABLE [@vTableSchemaName].[@vTablePrefix@vTableName];' + CHAR(13);
		SET	@vSQL = @vSQL + N'CREATE TABLE [@vTableSchemaName].[@vTablePrefix@vTableName] (' + CHAR(13) + N'@vColumnsDDL' + CHAR(13) + N')WITH(DATA_COMPRESSION=PAGE);';
		SET	@vObjectToBeGenerated = N'[@vTableSchemaName].[@vTablePrefix@vTableName]';
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vTableSchemaName',	@vTableSchemaName	);
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vTablePrefix',		@vTablePrefix		);
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vTableName',		@vTableName			);
		SET	@vColumnsDDL = N'';		
		DECLARE	column_cursor CURSOR
		FOR		SELECT	c.[ColumnDDL],c.[ColumnName]
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,DEFAULT,DEFAULT,DEFAULT,DEFAULT) c
				WHERE	c.[ColumnName] NOT IN (@vCreatedByColumnName,@vLastModifiedByColumnName)
                    AND c.[is_computed] <> 1
				ORDER	BY c.[column_id] ASC;

		OPEN	column_cursor;
		FETCH NEXT FROM column_cursor INTO @vColumnDDL,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT @vColumnDDL
				--END
				
				SET	@vColumnDDL = @vColumnDDL + CHAR(13);
				
				SET	@vColumnsDDL = @vColumnsDDL + @vColumnDDL;
				SET	@vLoopCounter += 1;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM column_cursor INTO @vColumnDDL,@vColumnName;
		END
		CLOSE	column_cursor;
		DEALLOCATE column_cursor;
		SET		@vRemark = REPLACE('@vLoopCounter columns built',N'@vLoopCounter',@vLoopCounter);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Build Columns'
				,	@pRemark				=	@vRemark;
				SET	@vColumnDDL = N',[PublishType]                                       tinyint              NOT NULL';
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT @vColumnDDL
				--END
				
				SET	@vColumnDDL = @vColumnDDL + CHAR(13);
				
				SET	@vColumnsDDL = @vColumnsDDL + @vColumnDDL;
				SET	@vLoopCounter += 1;

		SET		@vRemark = NULL;
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Append PublishType field'
				,	@pRemark				=	@vRemark;

		DECLARE	constraint_cursor CURSOR
		FOR		SELECT	[MirrorConstraintDDL],[MirrorConstraintName]
				FROM	[codegeneration].[udfDataWarehouseTableConstraintMetadata](@vTableName,@vTableSchemaName,@vTablePrefix,'',@vGlobalPrimaryKeyPrefix,@vGlobalUniqueKeyPrefix)c
				WHERE	c.[TransformConstraintName] <> 'Not relevant for Mirror table';
		OPEN	constraint_cursor;
		FETCH NEXT FROM constraint_cursor INTO @vColumnDDL,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				--SET	@vColumnDDL = REPLACE(@vColumnDDL,@vTableSchemaName + @vTableName,@vTableSchemaName + @vTablePrefix + @vTableName);
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT @vColumnDDL
				--END
				
				SET	@vColumnDDL = @vColumnDDL + CHAR(13);
				
				SET	@vColumnsDDL = @vColumnsDDL + @vColumnDDL;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM constraint_cursor INTO @vColumnDDL,@vColumnName;
		END

		CLOSE	constraint_cursor;
		DEALLOCATE constraint_cursor;

		/*Get rid of first comma*/
		SET	@vColumnsDDL = STUFF(@vColumnsDDL,1,1,' ');
		
		SET	@vSQL = REPLACE(@vSQL,	N'@vTablePrefix',			@vTablePrefix			);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableName',				@vTableName				);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableSchemaName',		@vTableSchemaName		);
		SET	@vSQL = REPLACE(@vSQL,	N'@vColumnsDDL',			@vColumnsDDL			);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END

		SET	@vViewPrefix =	REPLACE(N'@vGlobalViewPrefixMirror',N'@vGlobalViewPrefix',@vGlobalViewPrefix);
		SET	@vTablePrefix =	N'Mirror';
		SET	@vLoopCounter = 0;
		SET	@vViewSuffix =	@vGlobalCurrentViewSuffix;
		SET	@vObjectToBeGenerated = N'[@vTableSchemaName].[@vViewPrefix@vTableName@vViewSuffix]';
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vTableSchemaName',	@vTableSchemaName	);
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vViewPrefix',		@vViewPrefix		);
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vViewSuffix',		@vViewSuffix		);
		SET	@vSQL = N'IF EXISTS (SELECT 1 FROM [sys].[views] WHERE [name] = N''@vViewPrefix@vTableName@vViewSuffix'' AND SCHEMA_NAME([schema_id]) = N''@vTableSchemaName'') DROP VIEW @vObjectToBeGenerated;' + CHAR(13);
		SET	@vSQL = REPLACE(@vSQL,	N'@vObjectToBeGenerated',	@vObjectToBeGenerated	);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableName',				@vTableName				);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableSchemaName',		@vTableSchemaName		);
		SET	@vSQL = REPLACE(@vSQL,	N'@vViewPrefix',			@vViewPrefix			);
		SET	@vSQL = REPLACE(@vSQL,	N'@vViewSuffix',			@vViewSuffix			);
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
		SET	@vSQL = N'CREATE VIEW @vObjectToBeGenerated AS' + CHAR(13) + N'SELECT' + CHAR(13) + N'@vColumnsDDL' + N'FROM [@vTableSchemaName].[@vTablePrefix@vTableName] @vTablePrefix' + CHAR(13);
		SET	@vColumnsDDL = N'';		
		DECLARE	column_cursor CURSOR
		FOR		SELECT	c.[ColumnDML],c.[ColumnName]
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,1,@vTablePrefix,DEFAULT) c
				WHERE	c.[ColumnName] NOT IN (@vCreatedByColumnName,@vLastModifiedByColumnName)
                    AND c.[is_computed] <> 1
				ORDER	BY c.[column_id] ASC;

		OPEN	column_cursor;
		FETCH NEXT FROM column_cursor INTO @vColumnDDL,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT @vColumnDDL
				--END
				
				SET	@vColumnDDL = @vColumnDDL + CHAR(13);
				
				SET	@vColumnsDDL = @vColumnsDDL + @vColumnDDL;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM column_cursor INTO @vColumnDDL,@vColumnName;
		END
		CLOSE	column_cursor;
		DEALLOCATE column_cursor;
		SET		@vRemark = REPLACE('@vLoopCounter columns built',N'@vLoopCounter',@vLoopCounter);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Build Columns'
				,	@pRemark				=	@vRemark;
		
		IF(@vHasType2AttributeFlag = 1)
		BEGIN
				/*Table has type2 attributes thus there will be multiple records for the NKey. Need to get only one record, i.e. the latest (aka Current)*/
				SET	@vSQL	=	@vSQL + N'INNER JOIN (@vCurrentRecordSubQuery
)_current
ON		@vTablePrefix.[@vNKeyColumnName]	=	_current.[@vNKeyColumnName]
	AND	@vTablePrefix.[SCDValidFrom]		=	_current.[MaxSCDValidFrom]';
				SET	@vCurrentRecordSubQuery = N'
@vIndentSELECT	m.[@vNKeyColumnName],[MaxSCDValidFrom]=MAX(m.[SCDValidFrom])
@vIndentFROM	[@vTableSchemaName].[@vTablePrefix@vTableName] m
@vIndentGROUP	BY m.[@vNKeyColumnName]';
				SET	@vSQL = REPLACE(@vSQL,	N'@vCurrentRecordSubQuery',	@vCurrentRecordSubQuery	);
		END

		/*Let's be good T-SQL citizens!*/
		SET	@vSQL = @vSQL + N';';

		/*Get rid of first comma*/
		SET	@vColumnsDDL = STUFF(@vColumnsDDL,CHARINDEX(N',',@vColumnsDDL,1),1,' ');
		
		SET	@vSQL = REPLACE(@vSQL,	N'@vObjectToBeGenerated',	@vObjectToBeGenerated	);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableName',				@vTableName				);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableSchemaName',		@vTableSchemaName		);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTablePrefix',			@vTablePrefix			);
		SET	@vSQL = REPLACE(@vSQL,	N'@vViewPrefix',			@vViewPrefix			);
		SET	@vSQL = REPLACE(@vSQL,	N'@vViewSuffix',			@vViewSuffix			);
		SET	@vSQL = REPLACE(@vSQL,	N'@vColumnsDDL',			@vColumnsDDL			);
		SET	@vSQL = REPLACE(@vSQL,	N'@vNKeyColumnName',		@vNKeyColumnName		);
		SET	@vSQL = REPLACE(@vSQL,	N'@vIndent',				@vIndent				);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END

		SET	@vTablePrefix =	N'Transform';
		SET	@vLoopCounter = 0;
		SET	@vSQL = N'IF EXISTS (SELECT 1 FROM [sys].[tables] WHERE [name] = N''@vTablePrefix@vTableName'' AND SCHEMA_NAME([schema_id]) = N''@vTableSchemaName'') DROP TABLE [@vTableSchemaName].[@vTablePrefix@vTableName];' + CHAR(13);
		SET	@vSQL = @vSQL + N'CREATE TABLE [@vTableSchemaName].[@vTablePrefix@vTableName] (' + CHAR(13) + N'@vColumnsDDL' + CHAR(13) + N')WITH(DATA_COMPRESSION=PAGE);';
		SET	@vObjectToBeGenerated = N'[@vTableSchemaName].[@vTablePrefix@vTableName]';
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vTableSchemaName',	@vTableSchemaName	);
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vTablePrefix',		@vTablePrefix		);
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vTableName',		@vTableName			);
		SET	@vColumnsDDL = N'';		
		DECLARE	column_cursor CURSOR
		FOR		SELECT	c.[ColumnDDL],c.ColumnName
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,DEFAULT,DEFAULT,DEFAULT,DEFAULT) c
				WHERE	c.[IsLineage] = 0
					--AND	c.[IsSurrogateKey] = 0
					AND	c.[GenerateValue] = 0
                    AND c.[is_computed] <> 1
				ORDER	BY c.[column_id] ASC;

		OPEN	column_cursor;
		FETCH NEXT FROM column_cursor INTO @vColumnDDL,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT @vColumnDDL
				--END
				
				SET	@vColumnDDL = @vColumnDDL + CHAR(13);
				
				SET	@vColumnsDDL = @vColumnsDDL + @vColumnDDL;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM column_cursor INTO @vColumnDDL,@vColumnName;
		END
		CLOSE	column_cursor;
		DEALLOCATE column_cursor;
		SET		@vRemark = REPLACE('@vLoopCounter columns built',N'@vLoopCounter',@vLoopCounter);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Build Columns'
				,	@pRemark				=	@vRemark;
		
		
		SET	@vLoopCounter = 0;
		DECLARE	constraint_cursor CURSOR
		FOR		SELECT	[TransformConstraintDDL],[TransformConstraintName]
				FROM	[codegeneration].[udfDataWarehouseTableConstraintMetadata](@vTableName,@vTableSchemaName,'',@vTablePrefix,@vGlobalPrimaryKeyPrefix,@vGlobalUniqueKeyPrefix)c
				WHERE	c.[TransformConstraintName] <> 'Not relevant for Transform table';
		OPEN	constraint_cursor;
		FETCH NEXT FROM constraint_cursor INTO @vColumnDDL,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				--SET	@vColumnDDL = REPLACE(@vColumnDDL,@vTableSchemaName + @vTableName,@vTableSchemaName + @vTablePrefix + @vTableName);
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT @vColumnDDL
				--END
				
				SET	@vColumnDDL = @vColumnDDL + CHAR(13);
				
				SET	@vColumnsDDL = @vColumnsDDL + @vColumnDDL;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM constraint_cursor INTO @vColumnDDL,@vColumnName;
		END

		CLOSE	constraint_cursor;
		DEALLOCATE constraint_cursor;
		SET		@vRemark = REPLACE('@vLoopCounter constraints built',N'@vLoopCounter',@vLoopCounter);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Build Constraints'
				,	@pRemark				=	@vRemark;

		/*Get rid of first comma*/
		SET	@vColumnsDDL = STUFF(@vColumnsDDL,1,1,' ');

		SET	@vSQL = REPLACE(@vSQL,	N'@vTablePrefix',			@vTablePrefix			);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableName',				@vTableName				);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableSchemaName',		@vTableSchemaName		);
		SET	@vSQL = REPLACE(@vSQL,	N'@vColumnsDDL',			@vColumnsDDL			);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END

		SET	@vFunctionPrefix =	N'Template';
		SET	@vFunctionSchemaAndFunctionName = REPLACE(
													REPLACE(
														REPLACE(
															REPLACE(	N'[@vFunctionSchemaName].[@vGlobalFunctionPrefix@vFunctionPrefix@vFunctionName]',
																		N'@vFunctionName',
																		@vTableName
																	),
																	N'@vFunctionSchemaName',
																	@vTableSchemaName
																),
																N'@vFunctionPrefix',
																@vFunctionPrefix
															),
															N'@vGlobalFunctionPrefix',
															@vGlobalFunctionPrefix
														);
		SET	@vObjectToBeGenerated = @vFunctionSchemaAndFunctionName;
		IF (OBJECT_ID(@vFunctionSchemaAndFunctionName) IS NOT NULL)
		BEGIN
				IF	('$(ExecDynamicSQL)' = '1')
				BEGIN
						SET	@vSQL = N'DROP FUNCTION ' + @vFunctionSchemaAndFunctionName;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
				END
				SET		@vRemark = REPLACE('@vFunctionSchemaAndFunctionName already exists. Drop it!',N'@vFunctionSchemaAndFunctionName',@vFunctionSchemaAndFunctionName);
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Function'
						,	@pRemark				=	@vRemark;			
		END
		ELSE
		BEGIN
				SET		@vRemark = 'Function ''' + @vFunctionSchemaAndFunctionName + ''' does not already exist, no need to be DROPped!';
				PRINT	@vRemark;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Function'
						,	@pRemark				=	@vRemark;
		END

		/*OK, here's where we build our function*/
		SET		@vSQL	=	[codegeneration].[udfTemplateFunctionTemplate]();
		SET		@vSQL	=	REPLACE(@vSQL,N'@vFunctionSchemaAndFunctionName',	@vFunctionSchemaAndFunctionName);

		SET		@vSelectColumnsDML = N'';

		DECLARE	column_cursor CURSOR
		FOR		SELECT	c.[ColumnDML],c.ColumnName,c.[UnknownValue]
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,DEFAULT,DEFAULT) c
				WHERE	c.[GenerateValue] = 0
                    AND c.[is_computed] <> 1
				ORDER	BY c.[column_id] ASC;

		OPEN	column_cursor;
		FETCH NEXT FROM column_cursor INTO @vSelectColumnDML,@vColumnName,@vUnknownValue;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				SET	@vSelectColumnDML = @vSelectColumnDML + N' = ' + @vUnknownValue
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM column_cursor INTO @vSelectColumnDML,@vColumnName,@vUnknownValue;
		END
		CLOSE	column_cursor;
		DEALLOCATE column_cursor;
		SET		@vRemark = REPLACE('@vLoopCounter columns built',N'@vLoopCounter',@vLoopCounter);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Build Columns'
				,	@pRemark				=	@vRemark;

		/*Get rid of first comma*/
		SET	@vSelectColumnsDML = STUFF(@vSelectColumnsDML,CHARINDEX(N',',@vSelectColumnsDML,1),1,' ');

		SET		@vSQL	=	REPLACE(@vSQL,N'@vColumns',@vSelectColumnsDML)
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END

		IF (@vGenerateCopyToMirrorFlag = 1)
		BEGIN
		SET	@vProcedurePrefix =	N'CopyToMirror';
		SET	@vTablePrefix =	N'Mirror';
		SET	@vLoopCounter = 0;
		SET	@vProcedureSchemaAndProcedureName = REPLACE(
													REPLACE(
														REPLACE(
															REPLACE(	N'[@vProcedureSchemaName].[@vGlobalProcedurePrefix@vProcedurePrefix@vProcedureName]',
																		N'@vProcedureName',
																		@vTableName
																	),
																	N'@vProcedureSchemaName',
																	@vTableSchemaName
																),
																N'@vProcedurePrefix',
																@vProcedurePrefix
															),
															N'@vGlobalProcedurePrefix',
															@vGlobalProcedurePrefix
														);
		SET	@vObjectToBeGenerated = @vProcedureSchemaAndProcedureName;
		IF (OBJECT_ID(@vProcedureSchemaAndProcedureName) IS NOT NULL)
		BEGIN
				IF	('$(ExecDynamicSQL)' = '1')
				BEGIN
						SET	@vSQL = N'DROP PROCEDURE ' + @vProcedureSchemaAndProcedureName;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
				END
				SET		@vRemark = REPLACE('@vProcedureSchemaAndProcedureName already exists. Drop it!',N'@vProcedureSchemaAndProcedureName',@vProcedureSchemaAndProcedureName);
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;			
		END
		ELSE
		BEGIN
				SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' does not already exist, no need to be DROPped!';
				PRINT	@vRemark;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;
		END
		/*OK, here's where we build our stored procedure*/
		SET		@vSQL	=	[codegeneration].[udfStoredProcedureTemplate]();
		SET		@vSQL	=	REPLACE(@vSQL,N'@vProcedureSchemaAndProcedureName',	@vProcedureSchemaAndProcedureName);

		SET		@vInsertColumnsDML = N'';
		SET		@vSelectColumnsDML = N'';

		DECLARE	column_cursor CURSOR
		FOR		SELECT	c.[ColumnDML],c.[ColumnName]
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,DEFAULT,DEFAULT) c
				WHERE	c.[ColumnName] NOT IN (@vCreatedByColumnName,@vLastModifiedByColumnName)
                    AND c.[is_computed] <> 1
				ORDER	BY c.[column_id] ASC;

		OPEN	column_cursor;
		FETCH NEXT FROM column_cursor INTO @vSelectColumnDML,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				SET	@vInsertColumnDML = @vSelectColumnDML;
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumnDML = @vInsertColumnDML + CHAR(13);
				
				SET	@vInsertColumnsDML = @vInsertColumnsDML + @vInsertColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM column_cursor INTO @vSelectColumnDML,@vColumnName;
		END
		CLOSE	column_cursor;
		DEALLOCATE column_cursor;
		SET		@vRemark = REPLACE('@vLoopCounter columns built',N'@vLoopCounter',@vLoopCounter);
		SET		@vInsertColumnDML = REPLACE(N'@vIndent,[PublishType]',N'@vIndent',REPLICATE(N'@vIndent',2));
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumnDML = @vInsertColumnDML + CHAR(13);
				
				SET	@vInsertColumnsDML = @vInsertColumnsDML + @vInsertColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vSelectColumnDML = REPLACE(N'@vIndent,[PublishType] = @vPublishTypeIgnore',N'@vIndent',REPLICATE(N'@vIndent',2));
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Build Columns'
				,	@pRemark				=	@vRemark;

		/*Get rid of first comma*/
		SET	@vInsertColumnsDML = STUFF(@vInsertColumnsDML,CHARINDEX(N',',@vInsertColumnsDML,1),1,' ');
		SET	@vSelectColumnsDML = STUFF(@vSelectColumnsDML,CHARINDEX(N',',@vSelectColumnsDML,1),1,' ');

		SET		@vProcedureBody	=	N'TRUNCATE TABLE [@vTableSchemaName].[@vTablePrefix@vTableName];';
		IF	(@vHasGeneratedValues = 1)
				SET		@vProcedureBody	=	@vProcedureBody + N'
@vIndentSET IDENTITY_INSERT [@vTableSchemaName].[@vTablePrefix@vTableName] ON;';
		SET		@vProcedureBody	=	@vProcedureBody + N'
@vIndentINSERT INTO [@vTableSchemaName].[@vTablePrefix@vTableName] (
@vInsertColumnsDML@vIndent)
@vIndentSELECT
@vSelectColumnsDML@vIndentFROM	[$(DATA_WAREHOUSE_DATABASE_NAME)].[@vTableSchemaName].[@vTableName];
@vIndentSET		@pInsertCount	=	@@ROWCOUNT;';
		IF	(@vHasGeneratedValues = 1)
				SET		@vProcedureBody	=	@vProcedureBody + N'
@vIndentSET IDENTITY_INSERT [@vTableSchemaName].[@vTablePrefix@vTableName] OFF;';

		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vInsertColumnsDML',	@vInsertColumnsDML		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vSelectColumnsDML',	@vSelectColumnsDML		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableSchemaName',		@vTableSchemaName		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableName',			@vTableName				);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTablePrefix',			@vTablePrefix			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPublishTypeIgnore',	@vPublishTypeIgnore		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vIndent',				REPLICATE(@vIndent,4)	);
		SET		@vSQL	=	REPLACE(@vSQL,[codegeneration].[udfStoredProcedureTemplateBody](),@vProcedureBody)
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END

		END              
		IF (@vGenerateToTransformFlag = 1)
		BEGIN
		SET	@vViewPrefix =	REPLACE(N'@vGlobalViewPrefixMirror',N'@vGlobalViewPrefix',@vGlobalViewPrefix);
		SET	@vViewSuffix =	@vGlobalCurrentViewSuffix;
		SET	@vProcedurePrefix =	N'ToTransform';
		SET	@vFunctionPrefix =	N'Transform';
		SET	@vLoopCounter = 0;
		SET	@vFunctionSchemaAndFunctionName = REPLACE(
													REPLACE(
														REPLACE(
															REPLACE(	N'[@vProcedureSchemaName].[@vGlobalFunctionPrefix@vFunctionPrefix@vProcedureName]',
																		N'@vProcedureName',
																		@vTableName
																	),
																	N'@vProcedureSchemaName',
																	@vTableSchemaName
																),
																N'@vFunctionPrefix',
																@vFunctionPrefix
															),
															N'@vGlobalFunctionPrefix',
															@vGlobalFunctionPrefix
														);
		SET	@vProcedureSchemaAndProcedureName = REPLACE(
													REPLACE(
														REPLACE(
															REPLACE(	N'[@vProcedureSchemaName].[@vGlobalProcedurePrefix@vProcedurePrefix@vProcedureName]',
																		N'@vProcedureName',
																		@vTableName
																	),
																	N'@vProcedureSchemaName',
																	@vTableSchemaName
																),
																N'@vProcedurePrefix',
																@vProcedurePrefix
															),
															N'@vGlobalProcedurePrefix',
															@vGlobalProcedurePrefix
														);
		SET	@vObjectToBeGenerated = @vFunctionSchemaAndFunctionName;
		IF (OBJECT_ID(@vFunctionSchemaAndFunctionName) IS NOT NULL)
		BEGIN

				IF (@vGenerateToTransformFlag = 1)
				BEGIN
						IF	('$(ExecDynamicSQL)' = '1')
						BEGIN
								SET	@vSQL = N'DROP FUNCTION ' + @vFunctionSchemaAndFunctionName;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
								SET		@vRemark = REPLACE('@vFunctionSchemaAndFunctionName already exists. Drop it!',N'@vFunctionSchemaAndFunctionName',@vFunctionSchemaAndFunctionName);
								EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
											@pTableSchemaName		=	@vTableSchemaName
										,	@pTableName				=	@vTableName
										,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
										,	@pStep					=	N'Drop Function'
										,	@pRemark				=	@vRemark;				
						END
				END
				ELSE
						SET		@vRemark = 'Function ''' + @vFunctionSchemaAndFunctionName + ''' will not be dropped because GenerateToTransformFlag <> 1';
						EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
									@pTableSchemaName		=	@vTableSchemaName
								,	@pTableName				=	@vTableName
								,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
								,	@pStep					=	N'Dynamic SQL execution'
								,	@pRemark				=	@vRemark;
		END
		ELSE
		BEGIN
				SET		@vRemark = 'Function ''' + @vFunctionSchemaAndFunctionName + ''' does not already exist, no need to be DROPped!';
				PRINT	@vRemark;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Function'
						,	@pRemark				=	@vRemark;
		END
		/*OK, here's where we build our stored procedure*/
		SET		@vSQL	=	[codegeneration].[udfTransformFunctionBody]();
		SET		@vSQL	=	REPLACE(@vSQL,N'@vFunctionSchemaAndFunctionName',	@vFunctionSchemaAndFunctionName);
		SET		@vTablePrefix		=	N'Transform';
		SET		@vMirrorTablePrefix =	N'Mirror';

		SET		@vInsertColumnsDML = N'';
		SET		@vSelectColumnsDML = N'';
		SET		@vNKeyJoinColumnsDML = N'';

		DECLARE	column_cursor CURSOR
		FOR		SELECT	c.[ColumnDML],c.ColumnName,c.[ToTransformDML]
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,DEFAULT,DEFAULT) c
				WHERE	c.[GenerateValue]	=	0
					AND	c.[IsLineage]		=	0
                    AND c.[is_computed]     <>  1
				ORDER	BY c.[column_id] ASC;

		OPEN	column_cursor;
		FETCH NEXT FROM column_cursor INTO @vInsertColumnDML,@vColumnName,@vSelectColumnDML;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumnDML = @vInsertColumnDML + CHAR(13);
				
				SET	@vInsertColumnsDML = @vInsertColumnsDML + @vInsertColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM column_cursor INTO @vInsertColumnDML,@vColumnName,@vSelectColumnDML;
		END
		CLOSE	column_cursor;
		DEALLOCATE column_cursor;
		SET		@vRemark = REPLACE('@vLoopCounter columns built',N'@vLoopCounter',@vLoopCounter);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Build Columns'
				,	@pRemark				=	@vRemark;

		/*NKey columns*/
		DECLARE	nkeycolumn_cursor CURSOR
		FOR		SELECT	c.[ColumnName]
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,DEFAULT,DEFAULT) c
				WHERE	c.[IsNaturalKey]	=	1
				ORDER	BY c.[column_id] ASC;
		OPEN	nkeycolumn_cursor;
		FETCH NEXT FROM	nkeycolumn_cursor INTO @vColumnName;
		WHILE @@FETCH_STATUS = 0
		BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vNKeyJoinColumnDML		= N'AND	' + REPLACE(N'transform.[@vColumnName] = mirror.[@vColumnName]',N'@vColumnName',@vColumnName) + CHAR(13);
				
				SET	@vNKeyJoinColumnsDML = @vNKeyJoinColumnsDML + @vNKeyJoinColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM	nkeycolumn_cursor INTO @vColumnName;
		END
		CLOSE	nkeycolumn_cursor;
		DEALLOCATE	nkeycolumn_cursor;
		SET	@vNKeyJoinColumnsDML = STUFF(@vNKeyJoinColumnsDML,1,3,N'@vIndent@vIndentON'); --Replace the first AND with ON
		SET	@vNKeyJoinColumnsDML = REPLACE(@vNKeyJoinColumnsDML,N'AND',N'@vIndent@vIndentAND'); --Replace the first AND with ON

		/*Get rid of first comma*/
		SET	@vInsertColumnsDML = STUFF(@vInsertColumnsDML,CHARINDEX(N',',@vInsertColumnsDML,1),1,' ');
		SET	@vSelectColumnsDML = STUFF(@vSelectColumnsDML,CHARINDEX(N',',@vSelectColumnsDML,1),1,' ');

		SET		@vProcedureBody	=	N'
/*It should be pointed out that everything in this generated table-valued-function definition is 
basically for guidance. The purpose of this function is basically to provide data to the procedure
@vProcedureSchemaAndProcedureName.
If joins are required to other Functions, Transform or Mirror tables, that''s fine. Please though, try and 
make sure this function is an inline table-valued-function rather than a multistatement table-valued-function.
In other words, this should be a single SQL statement. There should be no table variable being declared if you
can at all help it.
Simple reason for preferrig inline TVFs over multistatement TVFs is that if the output of the TVF is getting joined/
aggregated/filtered the optimiser can treat an inline TVF like a view whereas a multistatement TVF will be treated 
like a table variable and thus any statistics on the underlying tables are ignored.

Please write your code between the UserCodeStart and UserCodeEnd comments, do not remove these comments as 
they may be used in the future for isolating user code from system code.
*/
@vIndent      
@vIndent      
@vIndent       /*UserCodeStart*/
@vIndent       
@vIndent		SELECT	
@vInsertColumnsDML@vIndent		FROM	[@vTableSchemaName].[@vGlobalFunctionPrefixTemplate@vTableName]()
@vIndent		WHERE	1=0
@vIndent       
@vIndent		/*UserCodeEnd*/

';

		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vInsertColumnsDML',		@vInsertColumnsDML		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vSelectColumnsDML',		@vSelectColumnsDML		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vNKeyJoinColumnsDML',		@vNKeyJoinColumnsDML	);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableSchemaName',			@vTableSchemaName		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableName',				@vTableName				);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTablePrefix',				@vTablePrefix			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vViewPrefix',				@vViewPrefix			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vViewSuffix',				@vViewSuffix			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vMirrorTablePrefix',		@vMirrorTablePrefix		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vFunctionPrefix',			@vFunctionPrefix		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vGlobalFunctionPrefix',	@vGlobalFunctionPrefix	);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vProcedureSchemaAndProcedureName',	@vProcedureSchemaAndProcedureName	);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vIndent',					REPLICATE(@vIndent,2)	);

		SET		@vSQL	=	REPLACE(@vSQL,'@vToTransformSelect',@vProcedureBody)
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;

IF (@vGenerateToTransformFlag = 1)
		BEGIN
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
		END
		ELSE
				SET		@vRemark = 'Function ''' + @vFunctionSchemaAndFunctionName + ''' will not be generated because GenerateToTransformFlag <> 1';
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vRemark;
						


		SET	@vViewPrefix =	REPLACE(N'@vGlobalViewPrefixMirror',N'@vGlobalViewPrefix',@vGlobalViewPrefix);
		SET	@vViewSuffix =	@vGlobalCurrentViewSuffix;
		SET	@vProcedurePrefix =	N'ToTransform';
		SET	@vLoopCounter = 0;
		SET	@vProcedureSchemaAndProcedureName = REPLACE(
													REPLACE(
														REPLACE(
															REPLACE(	N'[@vProcedureSchemaName].[@vGlobalProcedurePrefix@vProcedurePrefix@vProcedureName]',
																		N'@vProcedureName',
																		@vTableName
																	),
																	N'@vProcedureSchemaName',
																	@vTableSchemaName
																),
																N'@vProcedurePrefix',
																@vProcedurePrefix
															),
															N'@vGlobalProcedurePrefix',
															@vGlobalProcedurePrefix
														);
		SET	@vObjectToBeGenerated = @vProcedureSchemaAndProcedureName;
		IF (OBJECT_ID(@vProcedureSchemaAndProcedureName) IS NOT NULL)
		BEGIN

				IF (@vGenerateToTransformFlag = 1)
				BEGIN
						IF	('$(ExecDynamicSQL)' = '1')
						BEGIN
								SET	@vSQL = N'DROP PROCEDURE ' + @vProcedureSchemaAndProcedureName;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
								SET		@vRemark = REPLACE('@vProcedureSchemaAndProcedureName already exists. Drop it!',N'@vProcedureSchemaAndProcedureName',@vProcedureSchemaAndProcedureName);
								EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
											@pTableSchemaName		=	@vTableSchemaName
										,	@pTableName				=	@vTableName
										,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
										,	@pStep					=	N'Drop Procedure'
										,	@pRemark				=	@vRemark;				
						END
				END
				ELSE
						SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' will not be dropped because GenerateToTransformFlag <> 1';
						EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
									@pTableSchemaName		=	@vTableSchemaName
								,	@pTableName				=	@vTableName
								,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
								,	@pStep					=	N'Dynamic SQL execution'
								,	@pRemark				=	@vRemark;
		END
		ELSE
		BEGIN
				SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' does not already exist, no need to be DROPped!';
				PRINT	@vRemark;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;
		END
		/*OK, here's where we build our stored procedure*/
		SET		@vSQL	=	REPLACE(REPLACE([codegeneration].[udfStoredProcedureTemplate](),N'BEGIN TRAN;',N''),N'COMMIT TRAN;',N'');
		SET		@vSQL	=	REPLACE(@vSQL,N'@vProcedureSchemaAndProcedureName',	@vProcedureSchemaAndProcedureName);
		SET		@vTablePrefix		=	N'Transform';
		SET		@vMirrorTablePrefix =	N'Mirror';

		SET		@vInsertColumnsDML = N'';
		SET		@vSelectColumnsDML = N'';
		SET		@vNKeyJoinColumnsDML = N'';

		DECLARE	column_cursor CURSOR
		FOR		SELECT	c.[ColumnDML],c.ColumnName,c.[ToTransformDML]
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,DEFAULT,DEFAULT) c
				WHERE	c.[GenerateValue]	=	0
					AND	c.[IsLineage]		=	0
                    AND c.[is_computed]     <>  1
				ORDER	BY c.[column_id] ASC;

		OPEN	column_cursor;
		FETCH NEXT FROM column_cursor INTO @vInsertColumnDML,@vColumnName,@vSelectColumnDML;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumnDML = @vInsertColumnDML + CHAR(13);
				
				SET	@vInsertColumnsDML = @vInsertColumnsDML + @vInsertColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM column_cursor INTO @vInsertColumnDML,@vColumnName,@vSelectColumnDML;
		END
		CLOSE	column_cursor;
		DEALLOCATE column_cursor;
		SET		@vRemark = REPLACE('@vLoopCounter columns built',N'@vLoopCounter',@vLoopCounter);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Build Columns'
				,	@pRemark				=	@vRemark;

		/*NKey columns*/
		DECLARE	nkeycolumn_cursor CURSOR
		FOR		SELECT	c.[ColumnName]
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,DEFAULT,DEFAULT) c
				WHERE	c.[IsNaturalKey]	=	1
				ORDER	BY c.[column_id] ASC;
		OPEN	nkeycolumn_cursor;
		FETCH NEXT FROM	nkeycolumn_cursor INTO @vColumnName;
		WHILE @@FETCH_STATUS = 0
		BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vNKeyJoinColumnDML		= N'AND	' + REPLACE(N'transform.[@vColumnName] = mirror.[@vColumnName]',N'@vColumnName',@vColumnName) + CHAR(13);
				
				SET	@vNKeyJoinColumnsDML = @vNKeyJoinColumnsDML + @vNKeyJoinColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM	nkeycolumn_cursor INTO @vColumnName;
		END
		CLOSE	nkeycolumn_cursor;
		DEALLOCATE	nkeycolumn_cursor;
		SET	@vNKeyJoinColumnsDML = STUFF(@vNKeyJoinColumnsDML,1,3,N'@vIndent@vIndentON'); --Replace the first AND with ON
		SET	@vNKeyJoinColumnsDML = REPLACE(@vNKeyJoinColumnsDML,CHAR(13)+N'AND',CHAR(13)+N'@vIndent@vIndentAND');

		/*Get rid of first comma*/
		SET	@vInsertColumnsDML = STUFF(@vInsertColumnsDML,CHARINDEX(N',',@vInsertColumnsDML,1),1,' ');
		SET	@vSelectColumnsDML = STUFF(@vSelectColumnsDML,CHARINDEX(N',',@vSelectColumnsDML,1),1,' ');

		SET		@vProcedureBody	=	N'TRUNCATE TABLE [@vTableSchemaName].[@vTablePrefix@vTableName];
@vIndentINSERT INTO [@vTableSchemaName].[@vTablePrefix@vTableName] (
@vInsertColumnsDML@vIndent)
@vIndent/*This technique of using COALESCE to use either staged data, data from mirror, or from the template
@vIndent	is fairly common. The logic here is basically:
@vIndent	"IF we have a value from staged data, use that. If not, use what we have already (in mirror). If
@vIndent	we have neither, use the template."
@vIndent	This is a particularly useful technique when data for a dimension table is sourced from 
@vIndent	multiple systems-of-record (SoR) and we have records for a particular entity in one SoR
@vIndent	but not in another.
@vIndent
@vIndent	A word about the template function, this is a single-row function that provides a default value
@vIndent		for each column in the dimension.
@vIndent*/
@vIndentSELECT
@vSelectColumnsDML@vIndentFROM	(	
@vIndent		SELECT	
@vInsertColumnsDML@vIndent		FROM	[@vTableSchemaName].[@vGlobalFunctionPrefixTransform@vTableName]()

@vIndent) transform
@vIndentCROSS JOIN [@vTableSchemaName].[@vGlobalFunctionPrefixTemplate@vTableName]() template
@vIndentLEFT OUTER JOIN [@vTableSchemaName].[@vViewPrefix@vTableName@vViewSuffix] mirror
@vNKeyJoinColumnsDML
@vIndentUNION ALL
@vIndentSELECT
@vInsertColumnsDML@vIndentFROM	[@vTableSchemaName].[@vGlobalFunctionPrefixTemplate@vTableName]() template;
@vIndentSET		@pInsertCount	=	@@ROWCOUNT;
';

		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vInsertColumnsDML',		@vInsertColumnsDML		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vSelectColumnsDML',		@vSelectColumnsDML		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vNKeyJoinColumnsDML',		@vNKeyJoinColumnsDML	);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableSchemaName',			@vTableSchemaName		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableName',				@vTableName				);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTablePrefix',				@vTablePrefix			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vViewPrefix',				@vViewPrefix			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vViewSuffix',				@vViewSuffix			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vMirrorTablePrefix',		@vMirrorTablePrefix		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vGlobalFunctionPrefix',	@vGlobalFunctionPrefix	);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vIndent',				REPLICATE(@vIndent,4)	);
		SET		@vSQL	=	REPLACE(@vSQL,[codegeneration].[udfStoredProcedureTemplateBody](),@vProcedureBody)
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF (@vGenerateToTransformFlag = 1)
		BEGIN
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
		END
		ELSE
				SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' will not be generated because GenerateToTransformFlag <> 1';
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vRemark;
						
		END      		
		IF (@vGenerateToMirrorFlag = 1)
		BEGIN
		SET	@vProcedurePrefix =	N'ToMirror';
		SET	@vMirrorTablePrefix		=	N'Mirror';
		SET	@vTransformTablePrefix	=	N'Transform';
		SET	@vProcedureSchemaAndProcedureName = REPLACE(
													REPLACE(
														REPLACE(
															REPLACE(	N'[@vProcedureSchemaName].[@vGlobalProcedurePrefix@vProcedurePrefix@vProcedureName]',
																		N'@vProcedureName',
																		@vTableName
																	),
																	N'@vProcedureSchemaName',
																	@vTableSchemaName
																),
																N'@vProcedurePrefix',
																@vProcedurePrefix
															),
															N'@vGlobalProcedurePrefix',
															@vGlobalProcedurePrefix
														);
		SET	@vObjectToBeGenerated = @vProcedureSchemaAndProcedureName;
		IF (OBJECT_ID(@vProcedureSchemaAndProcedureName) IS NOT NULL)
		BEGIN
				IF	('$(ExecDynamicSQL)' = '1')
				BEGIN
						SET	@vSQL = N'DROP PROCEDURE ' + @vProcedureSchemaAndProcedureName;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
				END
				SET		@vRemark = REPLACE('@vProcedureSchemaAndProcedureName already exists. Drop it!',N'@vProcedureSchemaAndProcedureName',@vProcedureSchemaAndProcedureName);
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;			
		END
		ELSE
		BEGIN
				SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' does not already exist, no need to be DROPped!';
				PRINT	@vRemark;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;
		END
		/*OK, here's where we build our stored procedure*/
		SET		@vSQL	=	[codegeneration].[udfStoredProcedureTemplate]();
		SET		@vSQL	=	REPLACE(@vSQL,N'@vProcedureSchemaAndProcedureName',	@vProcedureSchemaAndProcedureName);
		
		SET		@vValuesColumnsDML						=	N'';
		SET		@vInsertColumnsDML						=	N'';
		SET		@vSelectColumnsDML						=	N'';
		SET		@vMergeType2UpdateConditionColumnsDML	=	N'';
		--SET		@vMergeType2UpdateSetColumnsDML		=	N'';
		SET		@vMergeType2OutputColumnsDML			=	N'';
		SET		@vMergeType1UpdateConditionColumnsDML	=	N'';
		SET		@vMergeType1UpdateSetColumnsDML			=	N'';	
		SET		@vWhenMatchedClause						=	N'';
		SET		@vNKeyJoinColumnsDML					=	N'';

		/*INSERT clause of the WHEN NOT MATCHED clause*/
		SET	@vLoopCounter = 0;
		DECLARE	insert_column_cursor CURSOR
		FOR		SELECT	c.[ColumnDML],c.[ColumnName]
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,DEFAULT,DEFAULT) c
				WHERE	c.[GenerateValue] = 0
					AND	c.[ColumnName] NOT IN (@vCreatedByColumnName,@vLastModifiedByColumnName)
                    AND c.[is_computed] <> 1
				ORDER	BY c.[column_id] ASC;
		OPEN	insert_column_cursor;
		FETCH NEXT FROM insert_column_cursor INTO @vInsertColumnDML,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumnDML = @vInsertColumnDML + CHAR(13);
				
				SET	@vInsertColumnsDML = @vInsertColumnsDML + @vInsertColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM insert_column_cursor INTO @vInsertColumnDML,@vColumnName;
		END
		CLOSE	insert_column_cursor;
		DEALLOCATE insert_column_cursor;
		SET		@vInsertColumnDML	=	N'@vIndent@vIndent,[PublishType]'
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumnDML = @vInsertColumnDML + CHAR(13);
				
				SET	@vInsertColumnsDML = @vInsertColumnsDML + @vInsertColumnDML;
				SET	@vLoopCounter += 1;
		--SET		@vInsertColumnDML	=	N'@vIndent@vIndent,tgt.[SCDValidTo]'
		--:r .\AppendInsertDMLWithLinefeed.sql
		--SET		@vInsertColumnDML	=	N'@vIndent@vIndent,tgt.[IsCurrent]'
		--:r .\AppendInsertDMLWithLinefeed.sql
		SET		@vInsertColumnsDML = STUFF(@vInsertColumnsDML,CHARINDEX(N',',@vInsertColumnsDML,1),1,' ');

		/*VALUES clause of the WHEN NOT MATCHED clause, type2 MERGE*/
		SET	@vLoopCounter = 0;
		DECLARE	values_column_cursor CURSOR
		FOR		SELECT	c.[ColumnDML],c.ColumnName
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,N'src',DEFAULT) c
				WHERE	c.[GenerateValue]	=	0
					AND	c.[IsLineage]		=	0
                    AND c.[is_computed]     <>  1
				ORDER	BY c.[column_id] ASC;
		OPEN	values_column_cursor;
		FETCH NEXT FROM values_column_cursor INTO @vValuesColumnDML,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vValuesColumnDML = @vValuesColumnDML + CHAR(13);
				
				SET	@vValuesColumnsDML = @vValuesColumnsDML + @vValuesColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM values_column_cursor INTO @vValuesColumnDML,@vColumnName;
		END
		CLOSE	values_column_cursor;
		DEALLOCATE values_column_cursor;
		SET		@vValuesColumnDML	=	N'@vIndent@vIndent,@vSCDTimestamp'	--SCDValidFrom
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vValuesColumnDML = @vValuesColumnDML + CHAR(13);
				
				SET	@vValuesColumnsDML = @vValuesColumnsDML + @vValuesColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vValuesColumnDML	=	N'@vIndent@vIndent,@vSCDEndOfTime'	--SCDValidTo
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vValuesColumnDML = @vValuesColumnDML + CHAR(13);
				
				SET	@vValuesColumnsDML = @vValuesColumnsDML + @vValuesColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vValuesColumnDML	=	N'@vIndent@vIndent,1'				--IsCurrent
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vValuesColumnDML = @vValuesColumnDML + CHAR(13);
				
				SET	@vValuesColumnsDML = @vValuesColumnsDML + @vValuesColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vValuesColumnDML	=	N'@vIndent@vIndent,@vPublishTypeInsert'
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vValuesColumnDML = @vValuesColumnDML + CHAR(13);
				
				SET	@vValuesColumnsDML = @vValuesColumnsDML + @vValuesColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vValuesColumnsDML = STUFF(@vValuesColumnsDML,CHARINDEX(N',',@vValuesColumnsDML,1),1,' ');

		/*WHEN MATCHED clause, type2 MERGE*/
		SET	@vLoopCounter = 0;
		SET	@vWhenMatchedClause	= N'
@vIndentWHEN MATCHED 
@vIndent@vIndentAND tgt.[IsCurrent] = 1
@vIndent@vIndentAND	(
@vMergeType2UpdateConditionColumnsDML@vindent@vindent)
@vIndentTHEN UPDATE SET
@vIndent@vIndent tgt.[SCDValidTo] = @vSCDTimestamp
@vIndent@vIndent,tgt.[IsCurrent] = 0
@vIndent@vIndent,tgt.[PublishType] = @vPublishTypeUpdate';
		DECLARE	mergetype2updateconditions_column_cursor CURSOR
		FOR		SELECT	c.[MergeUpdateConditionDML],c.ColumnName
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,10,N'src',N'tgt') c
				WHERE	c.[IsNaturalKey]		=	0
					AND	c.[IsLineage]			=	0
					AND	c.[IsType2Attribute]	=	1 /*Only interested in changes to type 2 attributes*/ 
                    AND c.[is_computed]         <>  1
				ORDER	BY c.[column_id] ASC;
		OPEN	mergetype2updateconditions_column_cursor;
		FETCH NEXT FROM mergetype2updateconditions_column_cursor INTO @vMergeType2UpdateConditionColumnDML,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				SET	@vLoopCounter += 1;
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vMergeType2UpdateConditionColumnDML
				--END
				
				SET	@vMergeType2UpdateConditionColumnDML = @vMergeType2UpdateConditionColumnDML + CHAR(13);
				
				SET	@vMergeType2UpdateConditionColumnsDML = @vMergeType2UpdateConditionColumnsDML + @vMergeType2UpdateConditionColumnDML;
				SET	@vLoopCounter += 1;

				--:r .\AppendMergetype2UpdateSetsDMLWithLinefeed.sql
				FETCH NEXT FROM mergetype2updateconditions_column_cursor INTO @vMergeType2UpdateConditionColumnDML,@vColumnName;
		END
		CLOSE	mergetype2updateconditions_column_cursor;
		DEALLOCATE mergetype2updateconditions_column_cursor;
		--SET		@vMergeType2UpdateSetColumnDML	=	N'@vIndent@vIndent,tgt.[SCDValidTo] = @vSCDEndOfTime'
		--:r .\AppendMergeUpdateSetsDMLWithLinefeed.sql
		--SET		@vMergeType2UpdateSetColumnDML	=	N'@vIndent@vIndent,tgt.[IsCurrent] = 0'
		--:r .\AppendMergeUpdateSetsDMLWithLinefeed.sql
		--SET		@vMergeType2UpdateSetColumnDML	=	N'@vIndent@vIndent,tgt.[PublishType] = @vPublishTypeUpdate'
		--:r .\AppendMergeUpdateSetsDMLWithLinefeed.sql
		SET		@vMergeType2UpdateConditionColumnsDML = STUFF(@vMergeType2UpdateConditionColumnsDML,CHARINDEX(N'OR',@vMergeType2UpdateConditionColumnsDML,1),2,' ');
		--SET		@vMergeType2UpdateSetColumnsDML = STUFF(@vMergeType2UpdateSetColumnsDML,CHARINDEX(N',',@vMergeType2UpdateSetColumnsDML,1),1,' ');
		SET		@vWhenMatchedClause = REPLACE(@vWhenMatchedClause,N'@vMergeType2UpdateConditionColumnsDML',	@vMergeType2UpdateConditionColumnsDML);
		--SET		@vWhenMatchedClause = REPLACE(@vWhenMatchedClause,N'@vMergeType2UpdateSetColumnsDML',		@vMergeType2UpdateSetColumnsDML);
		IF	@vLoopCounter = 0 SET	@vWhenMatchedClause = N'';/*If there are no type2 columns then there are no updates to be done*/
		
		/*OUTPUT clause, type2 MERGE*/
		SET	@vLoopCounter = 0;
		DECLARE	mergeoutput_column_cursor CURSOR
		FOR		SELECT	c.[ColumnDML],c.ColumnName
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,N'src',DEFAULT) c
				WHERE	c.[GenerateValue]		=	0
					AND	c.[IsLineage]			=	0
                    AND c.[is_computed]         <>  1
				ORDER	BY c.[column_id] ASC;
		OPEN	mergeoutput_column_cursor;
		FETCH NEXT FROM mergeoutput_column_cursor INTO @vMergeType2OutputColumnDML,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vMergeType2OutputColumnDML
				--END
				
				SET	@vMergeType2OutputColumnDML = @vMergeType2OutputColumnDML + CHAR(13);
				
				SET	@vMergeType2OutputColumnsDML = @vMergeType2OutputColumnsDML + @vMergeType2OutputColumnDML;
				SET	@vLoopCounter += 1;

				FETCH NEXT FROM mergeoutput_column_cursor INTO @vMergeType2OutputColumnDML,@vColumnName;
		END
		CLOSE	mergeoutput_column_cursor;
		DEALLOCATE mergeoutput_column_cursor;
		--SET		@vMergeType2OutputColumnDML	=	N'@vIndent@vIndent,DELETED.[IsCurrent] AS [PreviouslyWasCurrent]'
		--:r .\AppendMergetype2OutputDMLWithLinefeed.sql
		SET		@vMergeType2OutputColumnDML	=	N'@vIndent@vIndent,$Action AS [MergeAction]'
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vMergeType2OutputColumnDML
				--END
				
				SET	@vMergeType2OutputColumnDML = @vMergeType2OutputColumnDML + CHAR(13);
				
				SET	@vMergeType2OutputColumnsDML = @vMergeType2OutputColumnsDML + @vMergeType2OutputColumnDML;
				SET	@vLoopCounter += 1;

		SET		@vMergeType2OutputColumnsDML = STUFF(@vMergeType2OutputColumnsDML,CHARINDEX(N',',@vMergeType2OutputColumnsDML,1),1,' ');
		
		/*SELECT clause of the outer insertion, type2 MERGE*/
		SET	@vLoopCounter = 0;
		DECLARE	select_column_cursor CURSOR
		FOR		SELECT	c.[ColumnDML],c.ColumnName
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,N'mrg',DEFAULT) c
				WHERE	c.[GenerateValue]	=	0
					AND	c.[IsLineage]		=	0
                    AND c.[is_computed]     <>  1
				ORDER	BY c.[column_id] ASC;
		OPEN	select_column_cursor;
		FETCH NEXT FROM select_column_cursor INTO @vSelectColumnDML,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM select_column_cursor INTO @vSelectColumnDML,@vColumnName;
		END
		CLOSE	select_column_cursor;
		DEALLOCATE select_column_cursor;
		SET		@vSelectColumnDML	=	N'@vIndent@vIndent,@vSCDTimestamp'	--SCDValidFrom
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vSelectColumnDML	=	N'@vIndent@vIndent,@vSCDEndOfTime'	--SCDValidTo
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vSelectColumnDML	=	N'@vIndent@vIndent,1'				--IsCurrent
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vSelectColumnDML	=	N'@vIndent@vIndent,@vPublishTypeInsert'
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vSelectColumnsDML = STUFF(@vSelectColumnsDML,CHARINDEX(N',',@vSelectColumnsDML,1),1,' ');
		
		/*WHEN MATCHED clause, type1 MERGE*/
		DECLARE	mergetype1updateconditions_column_cursor CURSOR
		FOR		SELECT	c.[MergeUpdateConditionDML],c.[MergeUpdateSetDML],c.ColumnName
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,N'src',N'tgt') c
				WHERE	c.[GenerateValue]		=	0
					AND	c.[IsNaturalKey]		=	0
					AND	c.[IsLineage]			=	0
					AND	c.[IsType2Attribute]	=	0 /*Only interested in changes to type 1 attributes*/ 
                    AND c.[is_computed]         <>  1
				ORDER	BY c.[column_id] ASC;
		OPEN	mergetype1updateconditions_column_cursor;
		FETCH NEXT FROM mergetype1updateconditions_column_cursor INTO @vMergeType1UpdateConditionColumnDML,@vMergeType1UpdateSetColumnDML,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				SET	@vLoopCounter += 1;
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vMergeType1UpdateConditionColumnDML
				--END
				
				SET	@vMergeType1UpdateConditionColumnDML = @vMergeType1UpdateConditionColumnDML + CHAR(13);
				
				SET	@vMergeType1UpdateConditionColumnsDML = @vMergeType1UpdateConditionColumnsDML + @vMergeType1UpdateConditionColumnDML;
				SET	@vLoopCounter += 1;

				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vMergeType1UpdateSetColumnDML
				--END
				
				SET	@vMergeType1UpdateSetColumnDML = @vMergeType1UpdateSetColumnDML + CHAR(13);
				
				SET	@vMergeType1UpdateSetColumnsDML = @vMergeType1UpdateSetColumnsDML + @vMergeType1UpdateSetColumnDML;
				SET	@vLoopCounter += 1;

				FETCH NEXT FROM mergetype1updateconditions_column_cursor INTO @vMergeType1UpdateConditionColumnDML,@vMergeType1UpdateSetColumnDML,@vColumnName;
		END
		CLOSE	mergetype1updateconditions_column_cursor;
		DEALLOCATE mergetype1updateconditions_column_cursor;
		--SET		@vMergeType2UpdateSetColumnDML	=	N'@vIndent@vIndent,tgt.[SCDValidTo] = @vSCDEndOfTime'
		--:r .\AppendMergeUpdateSetsDMLWithLinefeed.sql
		--SET		@vMergeType2UpdateSetColumnDML	=	N'@vIndent@vIndent,tgt.[IsCurrent] = 0'
		--:r .\AppendMergeUpdateSetsDMLWithLinefeed.sql
		SET		@vMergeType1UpdateSetColumnDML	=	N'@vIndent@vIndent,tgt.[PublishType] = @vPublishTypeUpdate'
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vMergeType1UpdateSetColumnDML
				--END
				
				SET	@vMergeType1UpdateSetColumnDML = @vMergeType1UpdateSetColumnDML + CHAR(13);
				
				SET	@vMergeType1UpdateSetColumnsDML = @vMergeType1UpdateSetColumnsDML + @vMergeType1UpdateSetColumnDML;
				SET	@vLoopCounter += 1;

		SET		@vMergeType1UpdateConditionColumnsDML = STUFF(@vMergeType1UpdateConditionColumnsDML,CHARINDEX(N'OR',@vMergeType1UpdateConditionColumnsDML,1),2,' ');
		SET		@vMergeType1UpdateSetColumnsDML = STUFF(@vMergeType1UpdateSetColumnsDML,CHARINDEX(N',',@vMergeType1UpdateSetColumnsDML,1),1,' ');

		/*NKey columns*/
		DECLARE	nkeycolumn_cursor CURSOR
		FOR		SELECT	c.[ColumnName]
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,DEFAULT,DEFAULT) c
				WHERE	c.[IsNaturalKey]	=	1
				ORDER	BY c.[column_id] ASC;
		OPEN	nkeycolumn_cursor;
		FETCH NEXT FROM	nkeycolumn_cursor INTO @vColumnName;
		WHILE @@FETCH_STATUS = 0
		BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vNKeyJoinColumnDML		= N'AND	' + REPLACE(N'transform.[@vColumnName] = mirror.[@vColumnName]',N'@vColumnName',@vColumnName) + CHAR(13);
				
				SET	@vNKeyJoinColumnsDML = @vNKeyJoinColumnsDML + @vNKeyJoinColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM	nkeycolumn_cursor INTO @vColumnName;
		END
		CLOSE	nkeycolumn_cursor;
		DEALLOCATE	nkeycolumn_cursor;
		SET	@vNKeyJoinColumnsDML = STUFF(@vNKeyJoinColumnsDML,1,3,N'@vIndent@vIndentON'); --Replace the first AND with ON
		SET	@vNKeyJoinColumnsDML = REPLACE(@vNKeyJoinColumnsDML,CHAR(13)+N'AND',CHAR(13)+N'@vIndent@vIndentAND');
		--SET	@vNKeyJoinColumnsDML = REPLACE(@vNKeyJoinColumnsDML,N'AND',N'@vIndent@vIndentAND'); --Replace the first AND with ON
		SET	@vNKeyJoinColumnsDML = REPLACE(@vNKeyJoinColumnsDML,N'transform',N'src'); 
		SET	@vNKeyJoinColumnsDML = REPLACE(@vNKeyJoinColumnsDML,N'mirror',N'tgt'); 

		SET		@vProcedureBody	=	N'
@vIndentDECLARE	@vSCDTimestamp	[datetime]	=	CONVERT(datetime,SYSUTCDATETIME());
@vIndentDECLARE	@vSCDEndOfTime	[datetime]	=	CONVERT(datetime,''99991231'');

@vIndent/*Type2*/
@vIndentINSERT INTO [@vTableSchemaName].[@vMirrorTablePrefix@vTableName] (
@vInsertColumnsDML@vIndent)
@vIndentSELECT
@vSelectColumnsDML
@vIndentFROM	(
@vIndentMERGE INTO [@vTableSchemaName].[@vMirrorTablePrefix@vTableName] AS tgt
@vIndentUSING [@vTableSchemaName].[@vTransformTablePrefix@vTableName] AS src
@vNKeyJoinColumnsDML
@vIndentWHEN NOT MATCHED THEN
@vIndentINSERT (
@vInsertColumnsDML@vIndent)
@vIndentVALUES (
@vValuesColumnsDML@vIndent)@vWhenMatchedClause
@vIndentOUTPUT
@vMergeType2OutputColumnsDML
@vIndent) AS mrg
@vIndentWHERE	mrg.[MergeAction] = ''UPDATE''
@vIndent;

';
		IF (@vMergeType1UpdateConditionColumnsDML IS NOT NULL) --Possible that it will be NULL if there are no columns to be updated
		BEGIN
				SET		@vProcedureBody =	@vProcedureBody + N'
@vIndent/*Type1*/
@vIndentMERGE INTO [@vTableSchemaName].[@vMirrorTablePrefix@vTableName] AS tgt
@vIndentUSING [@vTableSchemaName].[@vTransformTablePrefix@vTableName] AS src
/*@vIndent@vIndentON	(src.[@vNKeyColumnName] = tgt.[@vNKeyColumnName])*/
@vNKeyJoinColumnsDML
@vIndentWHEN MATCHED
@vIndent@vIndentAND (
@vMergeType1UpdateConditionColumnsDML@vindent)
@vIndentTHEN UPDATE SET
@vMergeType1UpdateSetColumnsDML
@vIndent;';
		END
SET		@vProcedureBody =	@vProcedureBody + N'


@vIndentSET		@pInsertCount	=	(	SELECT	COUNT(*)
@vIndent								FROM	[@vTableSchemaName].[@vMirrorTablePrefix@vTableName]
@vIndent								WHERE	[PublishType] = @vPublishTypeInsert
									);
@vIndentSET		@pUpdateCount	=	(	SELECT	COUNT(*)
@vIndent								FROM	[@vTableSchemaName].[@vMirrorTablePrefix@vTableName]
@vIndent								WHERE	[PublishType] = @vPublishTypeUpdate
									);
@vIndentSET		@pDeleteCount	=	(	SELECT	COUNT(*)
@vIndent								FROM	[@vTableSchemaName].[@vMirrorTablePrefix@vTableName]
@vIndent								WHERE	[PublishType] = @vPublishTypeDelete
									);';
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vInsertColumnsDML',					@vInsertColumnsDML									);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vValuesColumnsDML',					@vValuesColumnsDML									);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vSelectColumnsDML',					@vSelectColumnsDML									);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vWhenMatchedClause',					@vWhenMatchedClause									);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vMergeType2OutputColumnsDML',			@vMergeType2OutputColumnsDML						);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vMergeType1UpdateConditionColumnsDML',	ISNULL(@vMergeType1UpdateConditionColumnsDML,N'')	);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vMergeType1UpdateSetColumnsDML',		@vMergeType1UpdateSetColumnsDML						);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vNKeyJoinColumnsDML',					@vNKeyJoinColumnsDML								);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableSchemaName',						@vTableSchemaName									);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableName',							@vTableName											);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTablePrefix',							@vTablePrefix										);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vMirrorTablePrefix',					@vMirrorTablePrefix									);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTransformTablePrefix',				@vTransformTablePrefix								);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPublishTypeInsert',					@vPublishTypeInsert									);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPublishTypeUpdate',					@vPublishTypeUpdate									);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPublishTypeDelete',					@vPublishTypeDelete									);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vIndent',								REPLICATE(@vIndent,4)								);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vNKeyColumnName',						@vNKeyColumnName									);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vSKeyColumnName',						@vSKeyColumnName									);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vSKeyColumnType',						@vSKeyColumnType									);
		SET		@vSQL	=	REPLACE(@vSQL,[codegeneration].[udfStoredProcedureTemplateBody](),@vProcedureBody)
		PRINT N'@vProcedureBody=' + ISNULL(@vProcedureBody,'')
		PRINT N'@vSQL=' + @vSQL

		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END

		END              
		IF (@vGeneratePublishFlag = 1)
		BEGIN
		SET	@vProcedurePrefix =	N'Publish';
		SET	@vTablePrefix =	N'Mirror';
		SET	@vLoopCounter = 0;
		SET	@vProcedureSchemaAndProcedureName = REPLACE(
													REPLACE(
														REPLACE(
															REPLACE(	N'[@vProcedureSchemaName].[@vGlobalProcedurePrefix@vProcedurePrefix@vProcedureName]',
																		N'@vProcedureName',
																		@vTableName
																	),
																	N'@vProcedureSchemaName',
																	@vTableSchemaName
																),
																N'@vProcedurePrefix',
																@vProcedurePrefix
															),
															N'@vGlobalProcedurePrefix',
															@vGlobalProcedurePrefix
														);
		SET	@vObjectToBeGenerated = @vProcedureSchemaAndProcedureName;
		IF (OBJECT_ID(@vProcedureSchemaAndProcedureName) IS NOT NULL)
		BEGIN
				IF	('$(ExecDynamicSQL)' = '1')
				BEGIN
						SET	@vSQL = N'DROP PROCEDURE ' + @vProcedureSchemaAndProcedureName;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
				END
				SET		@vRemark = REPLACE('@vProcedureSchemaAndProcedureName already exists. Drop it!',N'@vProcedureSchemaAndProcedureName',@vProcedureSchemaAndProcedureName);
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;			
		END
		ELSE
		BEGIN
				SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' does not already exist, no need to be DROPped!';
				PRINT	@vRemark;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;
		END
		/*OK, here's where we build our stored procedure*/
		SET		@vSQL	=	[codegeneration].[udfStoredProcedureTemplate]();
		SET		@vSQL	=	REPLACE(@vSQL,N'@vProcedureSchemaAndProcedureName',	@vProcedureSchemaAndProcedureName);

		SET		@vInsertColumnsDML = N'';
		SET		@vSelectColumnsDML = N'';
		SET		@vUpdateColumnsDML = N'';
		
		DECLARE	column_cursor CURSOR
		FOR		SELECT	c.[ColumnDML],c.[ColumnName]
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,DEFAULT,DEFAULT) c
				WHERE	c.[ColumnName] NOT IN (@vCreatedByColumnName,@vLastModifiedByColumnName)
                    AND c.[is_computed] <> 1
				ORDER	BY c.[column_id] ASC;

		OPEN	column_cursor;
		FETCH NEXT FROM column_cursor INTO @vSelectColumnDML,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				SET	@vInsertColumnDML = @vSelectColumnDML;
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumnDML = @vInsertColumnDML + CHAR(13);
				
				SET	@vInsertColumnsDML = @vInsertColumnsDML + @vInsertColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM column_cursor INTO @vSelectColumnDML,@vColumnName;
		END
		CLOSE	column_cursor;
		DEALLOCATE column_cursor;
		SET		@vInsertColumnDML = N'@vIndent,[@vCreatedByColumnName]';
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumnDML = @vInsertColumnDML + CHAR(13);
				
				SET	@vInsertColumnsDML = @vInsertColumnsDML + @vInsertColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vSelectColumnDML = N'@vIndent,[@vCreatedByColumnName] = @vLineageIDParameterName';
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vInsertColumnDML = N'@vIndent,[@vLastModifiedByColumnName]';
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumnDML = @vInsertColumnDML + CHAR(13);
				
				SET	@vInsertColumnsDML = @vInsertColumnsDML + @vInsertColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vSelectColumnDML = N'@vIndent,[@vLastModifiedByColumnName] = @vLineageIDParameterName';
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;

		SET		@vRemark = REPLACE('@vLoopCounter columns built',N'@vLoopCounter',@vLoopCounter);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Build Columns'
				,	@pRemark				=	@vRemark;

		DECLARE	update_column_cursor CURSOR
		FOR		SELECT	c.[MergeUpdateSetDML],c.[ColumnName]
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,4,N'src',N'tgt') c
				WHERE	c.[GenerateValue]		=	0
					AND	c.[IsNaturalKey]		=	0
					AND	c.[ColumnName] NOT IN (@vCreatedByColumnName,@vLastModifiedByColumnName)
                    AND c.[is_computed]         <>  1
				ORDER	BY c.[column_id] ASC;
		OPEN	update_column_cursor;
		FETCH NEXT FROM update_column_cursor INTO @vUpdateColumnDML,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				SET	@vLoopCounter += 1;
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vUpdateColumnDML
				--END
				
				SET	@vUpdateColumnDML = @vUpdateColumnDML + CHAR(13);
				
				SET	@vUpdateColumnsDML = @vUpdateColumnsDML + @vUpdateColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM update_column_cursor INTO @vUpdateColumnDML,@vColumnName;
		END
		CLOSE	update_column_cursor;
		DEALLOCATE update_column_cursor;
		SET	@vUpdateColumnDML	=	N'@vIndent,	tgt.[LastModifiedByLogID] = @pLogID';
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vUpdateColumnDML
				--END
				
				SET	@vUpdateColumnDML = @vUpdateColumnDML + CHAR(13);
				
				SET	@vUpdateColumnsDML = @vUpdateColumnsDML + @vUpdateColumnDML;
				SET	@vLoopCounter += 1;
		
		/*Get rid of first comma*/
		SET	@vInsertColumnsDML = STUFF(@vInsertColumnsDML,CHARINDEX(N',',@vInsertColumnsDML,1),1,' ');
		SET	@vSelectColumnsDML = STUFF(@vSelectColumnsDML,CHARINDEX(N',',@vSelectColumnsDML,1),1,' ');
		SET	@vUpdateColumnsDML = STUFF(@vUpdateColumnsDML,CHARINDEX(N',',@vUpdateColumnsDML,1),1,' ');

		SET		@vProcedureBody	=	N'/*INSERTs*/
@vIndentINSERT INTO [$(DATA_WAREHOUSE_DATABASE_NAME)].[@vTableSchemaName].[@vTableName] (
@vInsertColumnsDML@vIndent)
@vIndentSELECT
@vSelectColumnsDML@vIndentFROM	[@vTableSchemaName].[@vTablePrefix@vTableName]src
@vIndentWHERE	src.[PublishType] = @vPublishTypeInsert;
@vIndentSET		@pInsertCount	=	@@ROWCOUNT;

@vIndent/*UPDATEs*/
@vIndentUPDATE	tgt
@vIndentSET		
@vUpdateColumnsDML@vIndentFROM	[$(DATA_WAREHOUSE_DATABASE_NAME)].[@vTableSchemaName].[@vTableName] tgt
@vIndentINNER JOIN [@vTableSchemaName].[@vTablePrefix@vTableName] src
@vIndent@vIndentON	tgt.[@vSKeyColumnName]	=	src.[@vSKeyColumnName]
@vIndent@vIndentAND	src.[PublishType]		=	@vPublishTypeUpdate;
@vIndentSET		@pUpdateCount	=	@@ROWCOUNT;

@vIndent/*DELETEs not implemented*/';
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vInsertColumnsDML',			@vInsertColumnsDML			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vSelectColumnsDML',			@vSelectColumnsDML			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vUpdateColumnsDML',			@vUpdateColumnsDML			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableSchemaName',				@vTableSchemaName			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableName',					@vTableName					);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTablePrefix',					@vTablePrefix				);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPublishTypeInsert',			@vPublishTypeInsert			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPublishTypeUpdate',			@vPublishTypeUpdate			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vSKeyColumnName',				@vSKeyColumnName			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vCreatedByColumnName',			@vCreatedByColumnName		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vLastModifiedByColumnName',	@vLastModifiedByColumnName	);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vLineageIDParameterName',		@vLineageIDParameterName	);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vIndent',				REPLICATE(@vIndent,4)	);		
		SET		@vSQL	=	REPLACE(@vSQL,[codegeneration].[udfStoredProcedureTemplateBody](),@vProcedureBody)
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END

		END              
		FETCH NEXT FROM dimension_table_cursor INTO @vTableName,@vTableSchemaName,@vNKeyColumnName,@vGenerateToTransformFlag,@vSKeyColumnName,@vSKeyColumnType,@vHasType2AttributeFlag,@vHasGeneratedValues,@vGenerateCopyToMirrorFlag,@vGenerateToMirrorFlag,@vGeneratePublishFlag;
END

CLOSE	dimension_table_cursor;
DEALLOCATE	dimension_table_cursor;

/*Now do fact tables*/
DECLARE	fact_table_cursor CURSOR
FOR		SELECT	t.[TableName],t.[TableSchemaName],t.[GenerateToTransformFlag],t.[PartitionColumnName],t.[PartitionColumnTypeDefinition],t.[GenerateCopyToMirrorFlag],t.[GenerateToMirrorFlag],t.[GeneratePublishFlag]
		FROM	[codegeneration].[udfDataWarehouseTableMetadata](DEFAULT,DEFAULT,N'Fact',N'1')t
		WHERE	t.[DoETL] = 1;
		
OPEN fact_table_cursor;
FETCH NEXT FROM fact_table_cursor INTO @vTableName,@vTableSchemaName,@vGenerateToTransformFlag,@vPartitionKeyColumnName,@vPartitionKeyColumnTypeDefinition,@vGenerateCopyToMirrorFlag,@vGenerateToMirrorFlag,@vGeneratePublishFlag;;

WHILE @@FETCH_STATUS = 0
BEGIN
		PRINT	REPLACE(REPLACE(N'Generating ETL objects for [@vTableSchemaName].[@vTableName]','@vTableSchemaName',@vTableSchemaName),N'@vTableName',@vTableName);
		IF (@vGenerateToTransformFlag = 1)
		BEGIN
		--SET	@vViewPrefix =	REPLACE(N'@vGlobalViewPrefixMirror',N'@vGlobalViewPrefix',@vGlobalViewPrefix);
		--SET	@vViewSuffix =	@vGlobalCurrentViewSuffix;
		SET	@vProcedurePrefix =	N'ToTransform';
		SET	@vLoopCounter = 0;
		SET	@vProcedureSchemaAndProcedureName = REPLACE(
													REPLACE(
														REPLACE(
															REPLACE(	N'[@vProcedureSchemaName].[@vGlobalProcedurePrefix@vProcedurePrefix@vProcedureName]',
																		N'@vProcedureName',
																		@vTableName
																	),
																	N'@vProcedureSchemaName',
																	@vTableSchemaName
																),
																N'@vProcedurePrefix',
																@vProcedurePrefix
															),
															N'@vGlobalProcedurePrefix',
															@vGlobalProcedurePrefix
														);
		SET	@vObjectToBeGenerated = @vProcedureSchemaAndProcedureName;
		IF (@vGenerateToTransformFlag = 1)
		BEGIN
				IF (OBJECT_ID(@vProcedureSchemaAndProcedureName) IS NOT NULL)
				BEGIN
						IF	('$(ExecDynamicSQL)' = '1')
						BEGIN
								SET	@vSQL = N'DROP PROCEDURE ' + @vProcedureSchemaAndProcedureName;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
						END
						SET		@vRemark = REPLACE('@vProcedureSchemaAndProcedureName already exists. Drop it!',N'@vProcedureSchemaAndProcedureName',@vProcedureSchemaAndProcedureName);
						EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
									@pTableSchemaName		=	@vTableSchemaName
								,	@pTableName				=	@vTableName
								,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
								,	@pStep					=	N'Drop Procedure'
								,	@pRemark				=	@vRemark;			
				END
				ELSE
				BEGIN
						SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' does not already exist, no need to be DROPped!';
						PRINT	@vRemark;
						EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
									@pTableSchemaName		=	@vTableSchemaName
								,	@pTableName				=	@vTableName
								,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
								,	@pStep					=	N'Drop Procedure'
								,	@pRemark				=	@vRemark;
				END
		END
		ELSE
				SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' will not be dropped because GenerateToTransformFlag <> 1';
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vRemark;
		


		/*OK, here's where we build our stored procedure*/
		SET		@vSQL	=	REPLACE(REPLACE([codegeneration].[udfStoredProcedureTemplate](),N'BEGIN TRAN;',N''),N'COMMIT TRAN;',N'');
		SET		@vSQL	=	REPLACE(@vSQL,N'@vProcedureSchemaAndProcedureName',	@vProcedureSchemaAndProcedureName);
		SET		@vTablePrefix		=	N'Mirror';

		SET		@vInsertColumnsDML = N'';
		SET		@vSelectColumnsDML = N'';

		DECLARE	column_cursor CURSOR
		FOR		SELECT	c.[ColumnDML],c.ColumnName,c.[LookupColumnDML],c.[LookupColumnDML],c.[UnknownValue],c.[ReferencedColumnUnknownValue]
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,DEFAULT,DEFAULT) c
				WHERE	c.[IsSurrogateKey]	=	0
					AND	c.[IsLineage]		=	0
                    AND c.[is_computed]     <>  1
				ORDER	BY c.[column_id] ASC;

		OPEN	column_cursor;
		FETCH NEXT FROM column_cursor INTO @vInsertColumnDML,@vColumnName,@vLookupColumnDML,@vSelectColumnDML,@vUnknownValue,@vReferencedColumnUnknownValue;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				SET @vInsertColumnDML = ISNULL(@vLookupColumnDML,@vInsertColumnDML);
				SET	@vSelectColumnDML = ISNULL(@vSelectColumnDML,@vInsertColumnDML) + N'	=	' + ISNULL(@vReferencedColumnUnknownValue,@vUnknownValue);
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumnDML = @vInsertColumnDML + CHAR(13);
				
				SET	@vInsertColumnsDML = @vInsertColumnsDML + @vInsertColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM column_cursor INTO @vInsertColumnDML,@vColumnName,@vLookupColumnDML,@vSelectColumnDML,@vUnknownValue,@vReferencedColumnUnknownValue;
		END
		CLOSE	column_cursor;
		DEALLOCATE column_cursor;
		SET		@vRemark = REPLACE('@vLoopCounter columns built',N'@vLoopCounter',@vLoopCounter);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Build Columns'
				,	@pRemark				=	@vRemark;

		/*Get rid of first comma*/
		SET	@vInsertColumnsDML = STUFF(@vInsertColumnsDML,CHARINDEX(N',',@vInsertColumnsDML,1),1,' ');
		SET	@vSelectColumnsDML = STUFF(@vSelectColumnsDML,CHARINDEX(N',',@vSelectColumnsDML,1),1,' ');

		SET		@vProcedureBody	=	N'TRUNCATE TABLE [@vTableSchemaName].[@vTablePrefix@vTableName];
@vIndentINSERT INTO [@vTableSchemaName].[@vTablePrefix@vTableName] (
@vInsertColumnsDML@vIndent)
@vIndent/*It should be pointed out that everything in this generated stored procedure definition is 
@vIndent		basically for guidance. The purpose of this stored procedure is basically to populate
@vIndent		[@vTableSchemaName].[@vTablePrefix@vTableName]. 
@vIndent		The approach suggested in this generated stored proc is for guidance
@vIndent		and is an attempt to promote consistency, if there is a need to diversify from that 
@vIndent		consistent approach, that''s OK! If temp tables are required somewhere, that''s absolutely 
@vIndent		fine. If joins are required to other Transform or Mirror tables, that''s fine too. Anything
@vIndent		goes, as long as [@vTableSchemaName].[@vTablePrefix@vTableName] gets populated!!!
@vIndent*/
@vIndentSELECT
@vInsertColumnsDML@vIndentFROM	(	
@vIndent		/*This derived table (that has an alias of "transform") is here purely as a placeholder
@vIndent			and needs to be replaced with the code that converts staged data into 
@vIndent			whatever is required for the warehouse.
@vIndent			In other words, *this* is where our ETL work has to be done. This is the part that 
@vIndent			cannot be done with code-generation - it requires a human being.

@vIndent		  When development is complete it is imperative that the following steps are completed
@vIndent			-all superfluous comments herein (such as the one you are reading right now) are removed.
@vIndent			-ensure the GenerateToTransfromFlag extended property on [@vTableSchemaName].[@vTableName] 
@vIndent				is not set to ''1'' otherwise your changes will be overwritten!!!!
@vIndent			-Add your new definition of this stored procedure to the SSDT project, and check-in
@vIndent		*/
@vIndent		SELECT	
@vSelectColumnsDML
@vIndent		)transform
@vIndentWHERE	1 = 0
@vIndent;
@vIndentSET		@pInsertCount	=	@@ROWCOUNT;
';

		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Pre ProcedureBody Replace'
						,	@pRemark				=	@vProcedureBody;

		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vInsertColumnsDML',		@vInsertColumnsDML		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vSelectColumnsDML',		@vSelectColumnsDML		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableSchemaName',			@vTableSchemaName		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableName',				@vTableName				);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTablePrefix',				@vTablePrefix			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vGlobalFunctionPrefix',	@vGlobalFunctionPrefix	);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vIndent',				REPLICATE(@vIndent,4)	);
		SET		@vSQL	=	REPLACE(@vSQL,[codegeneration].[udfStoredProcedureTemplateBody](),@vProcedureBody)
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF (@vGenerateToTransformFlag = 1)
		BEGIN
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
		END
		ELSE
				SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' will not be generated because GenerateToTransformFlag <> 1';
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vRemark;
						
		
		END              
        SET	@vTablePrefix =	N'Mirror';
        SET	@vLoopCounter = 0;
        SET	@vSQL = N'IF EXISTS (SELECT 1 FROM [sys].[tables] WHERE [name] = N''@vTablePrefix@vTableName'' AND SCHEMA_NAME([schema_id]) = N''@vTableSchemaName'') DROP TABLE [@vTableSchemaName].[@vTablePrefix@vTableName];' + CHAR(13);
        SET	@vSQL = @vSQL + N'CREATE TABLE [@vTableSchemaName].[@vTablePrefix@vTableName] (' + CHAR(13) + N'@vColumnsDDL' + CHAR(13) + N')WITH(DATA_COMPRESSION=PAGE);';
        SET	@vObjectToBeGenerated = N'[@vTableSchemaName].[@vTablePrefix@vTableName]';
        SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vTableSchemaName',	@vTableSchemaName	);
        SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vTablePrefix',		@vTablePrefix		);
        SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vTableName',		@vTableName			);
        SET	@vColumnsDDL = N'';
        DECLARE	column_cursor CURSOR
        FOR		SELECT	c.[MirrorColumnDDL],c.ColumnName,c.[LookupColumnDDL]
                FROM	(
                        SELECT	c.[column_id],c.[MirrorColumnDDL],c.ColumnName,[LookupColumnDDL]=MIN(c.[LookupColumnDDL])--=r_c.[ColumnDDL]
                        FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,DEFAULT,DEFAULT,DEFAULT,DEFAULT) c
                        WHERE	c.[IsLineage] = 0
                            AND c.[is_computed] <> 1
                        GROUP BY c.[column_id],c.[MirrorColumnDDL],c.ColumnName
                        )c
                ORDER	BY c.[column_id] ASC;
        OPEN	column_cursor;
        FETCH NEXT FROM column_cursor INTO @vColumnDDL,@vColumnName,@vLookupColumnDDL;
        WHILE	@@FETCH_STATUS = 0
        BEGIN
                IF (@vLookupColumnDDL IS NOT NULL)
                BEGIN
                        /*Column has a foreign key so create a column for the NKey of the referenced table, and make the column NULLable (because we'll update it later by looking up the value from the referenced table)*/
                        SET	@vColumnDDL = REPLACE(@vColumnDDL,N'NOT NULL',N'NULL');
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT @vColumnDDL
				--END
				
				SET	@vColumnDDL = @vColumnDDL + CHAR(13);
				
				SET	@vColumnsDDL = @vColumnsDDL + @vColumnDDL;
				SET	@vLoopCounter += 1;
                        /*In case of junk dimensions there will be more than one lookup column so we need to loop over and add each of them*/
                        DECLARE	lookupcolumn_cursor CURSOR
                        FOR		SELECT	c.[LookupColumnDDL]
                                FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,DEFAULT,DEFAULT,DEFAULT,DEFAULT) c
                                WHERE	c.[ColumnName] = @vColumnName;
                        OPEN	lookupcolumn_cursor;
                        FETCH NEXT FROM lookupcolumn_cursor INTO @vColumnDDL;
                        WHILE @@FETCH_STATUS = 0
                        BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT @vColumnDDL
				--END
				
				SET	@vColumnDDL = @vColumnDDL + CHAR(13);
				
				SET	@vColumnsDDL = @vColumnsDDL + @vColumnDDL;
				SET	@vLoopCounter += 1;
                                FETCH NEXT FROM lookupcolumn_cursor INTO @vColumnDDL;
                        END
                        CLOSE	lookupcolumn_cursor;
                        DEALLOCATE lookupcolumn_cursor;
                END
                ELSE
                BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT @vColumnDDL
				--END
				
				SET	@vColumnDDL = @vColumnDDL + CHAR(13);
				
				SET	@vColumnsDDL = @vColumnsDDL + @vColumnDDL;
				SET	@vLoopCounter += 1;
                END
                SET	@vLoopCounter += 1;
                FETCH NEXT FROM column_cursor INTO @vColumnDDL,@vColumnName,@vLookupColumnDDL;
        END
        CLOSE	column_cursor;
        DEALLOCATE column_cursor;
        SET		@vRemark = REPLACE('@vLoopCounter columns built',N'@vLoopCounter',@vLoopCounter);
        EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
                    @pTableSchemaName		=	@vTableSchemaName
                ,	@pTableName				=	@vTableName
                ,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
                ,	@pStep					=	N'Build Columns'
                ,	@pRemark				=	@vRemark;
        
        
        SET	@vLoopCounter = 0;
        DECLARE	constraint_cursor CURSOR
        FOR		SELECT	[TransformConstraintDDL],[TransformConstraintName]
                FROM	[codegeneration].[udfDataWarehouseTableConstraintMetadata](@vTableName,@vTableSchemaName,'',@vTablePrefix,@vGlobalPrimaryKeyPrefix,@vGlobalUniqueKeyPrefix)c;
        OPEN	constraint_cursor;
        FETCH NEXT FROM constraint_cursor INTO @vColumnDDL,@vColumnName;
        WHILE	@@FETCH_STATUS = 0
        BEGIN
                --SET	@vColumnDDL = REPLACE(@vColumnDDL,@vTableSchemaName + @vTableName,@vTableSchemaName + @vTablePrefix + @vTableName);
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT @vColumnDDL
				--END
				
				SET	@vColumnDDL = @vColumnDDL + CHAR(13);
				
				SET	@vColumnsDDL = @vColumnsDDL + @vColumnDDL;
				SET	@vLoopCounter += 1;
                SET	@vLoopCounter += 1;
                FETCH NEXT FROM constraint_cursor INTO @vColumnDDL,@vColumnName;
        END

        CLOSE	constraint_cursor;
        DEALLOCATE constraint_cursor;
        SET		@vRemark = REPLACE('@vLoopCounter constraints built',N'@vLoopCounter',@vLoopCounter);
        EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
                    @pTableSchemaName		=	@vTableSchemaName
                ,	@pTableName				=	@vTableName
                ,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
                ,	@pStep					=	N'Build Constraints'
                ,	@pRemark				=	@vRemark;

        /*Get rid of first comma*/
        SET	@vColumnsDDL = STUFF(@vColumnsDDL,1,1,' ');

        SET	@vSQL = REPLACE(@vSQL,	N'@vTablePrefix',			@vTablePrefix			);
        SET	@vSQL = REPLACE(@vSQL,	N'@vTableName',				@vTableName				);
        SET	@vSQL = REPLACE(@vSQL,	N'@vTableSchemaName',		@vTableSchemaName		);
        SET	@vSQL = REPLACE(@vSQL,	N'@vColumnsDDL',			@vColumnsDDL			);
        EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
                    @pTableSchemaName		=	@vTableSchemaName
                ,	@pTableName				=	@vTableName
                ,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
                ,	@pStep					=	N'Dynamic SQL build complete'
                ,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END

		IF (@vGenerateCopyToMirrorFlag = 1)
		BEGIN
		SET	@vProcedurePrefix =	N'CopyToMirror';
		SET	@vTablePrefix =	N'Mirror';
		SET	@vLoopCounter = 0;
		SET	@vProcedureSchemaAndProcedureName = REPLACE(
													REPLACE(
														REPLACE(
															REPLACE(	N'[@vProcedureSchemaName].[@vGlobalProcedurePrefix@vProcedurePrefix@vProcedureName]',
																		N'@vProcedureName',
																		@vTableName
																	),
																	N'@vProcedureSchemaName',
																	@vTableSchemaName
																),
																N'@vProcedurePrefix',
																@vProcedurePrefix
															),
															N'@vGlobalProcedurePrefix',
															@vGlobalProcedurePrefix
														);
		SET	@vObjectToBeGenerated = @vProcedureSchemaAndProcedureName;
		IF (OBJECT_ID(@vProcedureSchemaAndProcedureName) IS NOT NULL)
		BEGIN
				IF	('$(ExecDynamicSQL)' = '1')
				BEGIN
						SET	@vSQL = N'DROP PROCEDURE ' + @vProcedureSchemaAndProcedureName;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
				END
				SET		@vRemark = REPLACE('@vProcedureSchemaAndProcedureName already exists. Drop it!',N'@vProcedureSchemaAndProcedureName',@vProcedureSchemaAndProcedureName);
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;			
		END
		ELSE
		BEGIN
				SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' does not already exist, no need to be DROPped!';
				PRINT	@vRemark;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;
		END
		/*OK, here's where we build our stored procedure*/
		SET		@vSQL	=	[codegeneration].[udfStoredProcedureTemplate]();
		SET		@vSQL	=	REPLACE(@vSQL,N'@vProcedureSchemaAndProcedureName',	@vProcedureSchemaAndProcedureName);

		

		SET		@vProcedureBody	=	N'TRUNCATE TABLE [@vTableSchemaName].[@vTablePrefix@vTableName];';

		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vInsertColumnsDML',	@vInsertColumnsDML		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vSelectColumnsDML',	@vSelectColumnsDML		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableSchemaName',		@vTableSchemaName		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableName',			@vTableName				);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTablePrefix',			@vTablePrefix			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPublishTypeIgnore',	@vPublishTypeIgnore		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vIndent',				REPLICATE(@vIndent,4)	);
		SET		@vSQL	=	REPLACE(@vSQL,[codegeneration].[udfStoredProcedureTemplateBody](),@vProcedureBody)
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END

		END              
		IF (@vGenerateToMirrorFlag = 1)
		BEGIN
        SET	@vProcedurePrefix =	N'ToMirror';
        SET	@vMirrorTablePrefix		=	N'Mirror';
        SET	@vTransformTablePrefix	=	N'Transform';
        SET	@vLoopCounter = 0;
        SET	@vProcedureSchemaAndProcedureName = REPLACE(
                                                    REPLACE(
                                                        REPLACE(
                                                            REPLACE(	N'[@vProcedureSchemaName].[@vGlobalProcedurePrefix@vProcedurePrefix@vProcedureName]',
                                                                        N'@vProcedureName',
                                                                        @vTableName
                                                                    ),
                                                                    N'@vProcedureSchemaName',
                                                                    @vTableSchemaName
                                                                ),
                                                                N'@vProcedurePrefix',
                                                                @vProcedurePrefix
                                                            ),
                                                            N'@vGlobalProcedurePrefix',
                                                            @vGlobalProcedurePrefix
                                                        );
        SET	@vObjectToBeGenerated = @vProcedureSchemaAndProcedureName;
        IF (OBJECT_ID(@vProcedureSchemaAndProcedureName) IS NOT NULL)
        BEGIN
                IF	('$(ExecDynamicSQL)' = '1')
                BEGIN
                        SET	@vSQL = N'DROP PROCEDURE ' + @vProcedureSchemaAndProcedureName;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
                END
                SET		@vRemark = REPLACE('@vProcedureSchemaAndProcedureName already exists. Drop it!',N'@vProcedureSchemaAndProcedureName',@vProcedureSchemaAndProcedureName);
                EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
                            @pTableSchemaName		=	@vTableSchemaName
                        ,	@pTableName				=	@vTableName
                        ,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
                        ,	@pStep					=	N'Drop Procedure'
                        ,	@pRemark				=	@vRemark;			
        END
        ELSE
        BEGIN
                SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' does not already exist, no need to be DROPped!';
                PRINT	@vRemark;
                EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
                            @pTableSchemaName		=	@vTableSchemaName
                        ,	@pTableName				=	@vTableName
                        ,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
                        ,	@pStep					=	N'Drop Procedure'
                        ,	@pRemark				=	@vRemark;
        END

        /*OK, here's where we build our stored procedure*/
        SET		@vSQL	=	[codegeneration].[udfStoredProcedureTemplate]();
        SET		@vSQL	=	REPLACE(@vSQL,N'@vProcedureSchemaAndProcedureName',	@vProcedureSchemaAndProcedureName);
        
        SET		@vProcedureBody	=	N'
@vIndentDECLARE	@vSCDTimestamp			[datetime]	=	CONVERT(datetime,SYSUTCDATETIME());
@vIndentDECLARE	@vSCDEndOfTime			[datetime]	=	CONVERT(datetime,''99991231'');
@vIndentDECLARE	@vInferredMemberTally	[int]		=	0;
@vIndentDECLARE	@vRemark				[NVARCHAR](4000);
@vIndentDECLARE @vMirrorTableRowCount   [INT]       =   0;
@vIndentDECLARE @vUpdatedRowCount       [INT]       =   0;

@vIndent/*Count number of rows in the table. This will be used to determine whether or not all rows have been updated or not*/
@vIndentSET @vMirrorTableRowCount = (
@vIndent@vIndentSELECT  SUM(p.[rows])
@vIndent@vIndentFROM    sys.partitions p
@vIndent@vIndentWHERE   OBJECT_NAME(p.object_id) = ''@vMirrorTablePrefix@vTableName''
@vIndent@vIndent    AND p.[index_id] < 2
@vIndent);

@vIndent/*Lookup surrogate keys*/
@vIndentDECLARE	@vNullCount	INT;';

        /*Loop over SKs and lookup the appropriate SK value from the respective dimension table*/
        DECLARE	lookup_cursor CURSOR
        FOR		SELECT	c.[ColumnName],c.[ReferencedTableName],c.[ReferencedTableSchemaName],c.[ReferencedColumnName]
                FROM	(
                        SELECT	c.[column_id],c.[ColumnName],c.[ReferencedTableName],c.[ReferencedTableSchemaName],c.[ReferencedColumnName]--,c.[ReferencedTableNKeyColumnName],c.[LookupColumnName]
                        FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,DEFAULT,DEFAULT,DEFAULT,DEFAULT)c
                        WHERE	c.[ReferencedTableName] IS NOT NULL
                            AND c.[ReferencedTableName] <> N'DimDate'  --No need to lookup values for DimDate because it uses smart keys
                            AND c.[ReferencedTableName] <> N'DimTime'  --No need to lookup values for DimTime because it uses smart keys
                        GROUP	BY c.[column_id],c.[ColumnName],c.[ReferencedTableName],c.[ReferencedTableSchemaName],c.[ReferencedColumnName]
                        )c
                ORDER	BY c.[column_id] ASC;
        OPEN	lookup_cursor;
        FETCH NEXT FROM lookup_cursor INTO @vColumnName,@vReferencedTableName,@vReferencedTableSchemaName,@vReferencedColumnName;--,@vReferencedTableNKeyColumnName,@vLookupColumnName;
        WHILE	@@FETCH_STATUS = 0
        BEGIN
                SET     @vFirstNKeyJoinColumn = NULL;
                SET		@vInferredMemberCreation = N'';
                SET		@vNKeyJoinColumnsDML = N'';
                DECLARE	nkeycolumn_cursor CURSOR
                FOR		SELECT	c.[ReferencedTableNKeyColumnName],c.[LookupColumnName]
                        FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,DEFAULT,DEFAULT,DEFAULT,DEFAULT)c
                        WHERE	c.[ReferencedTableName] IS NOT NULL
                            AND	c.[ColumnName] = @vColumnName;
                OPEN	nkeycolumn_cursor;
                FETCH NEXT FROM nkeycolumn_cursor INTO @vReferencedTableNKeyColumnName,@vLookupColumnName;
                WHILE	@@FETCH_STATUS = 0
                BEGIN
                        SET @vFirstNKeyJoinColumn = ISNULL(@vFirstNKeyJoinColumn,@vReferencedTableNKeyColumnName);
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vNKeyJoinColumnDML		= N'AND	' + REPLACE(REPLACE(N'tgt.[@vLookupColumnName] = src.[@vReferencedTableNKeyColumnName]',N'@vLookupColumnName',@vLookupColumnName),N'@vReferencedTableNKeyColumnName',@vReferencedTableNKeyColumnName) + CHAR(13);
				
				SET	@vNKeyJoinColumnsDML = @vNKeyJoinColumnsDML + @vNKeyJoinColumnDML;
				SET	@vLoopCounter += 1;
                        FETCH NEXT FROM nkeycolumn_cursor INTO @vReferencedTableNKeyColumnName,@vLookupColumnName;
                END
                CLOSE	nkeycolumn_cursor;
                DEALLOCATE nkeycolumn_cursor;
                SET	@vNKeyJoinColumnsDML = STUFF(@vNKeyJoinColumnsDML,1,3,N'@vIndent@vIndentON'); --Replace the first AND with ON
                SET	@vNKeyJoinColumnsDML = REPLACE(@vNKeyJoinColumnsDML,CONVERT(NCHAR(1),CHAR(10)) + N'AND',CONVERT(NCHAR(1),CHAR(10)) + N'@vIndent@vIndentAND'); 
                SET	@vNKeyJoinColumnsDML = REPLACE(@vNKeyJoinColumnsDML,N'transform',N'src'); 
                SET	@vNKeyJoinColumnsDML = REPLACE(@vNKeyJoinColumnsDML,N'mirror',N'tgt'); 

                SET		@vLookupUpdateQuery = N'@vIndent/*@vReferencedTableName lookup*/
@vIndentUPDATE	tgt
@vIndentSET		[@vColumnName] = src.[@vReferencedColumnName]
@vIndentFROM	[@vTableSchemaName].[@vMirrorTablePrefix@vTableName] tgt
@vIndentINNER JOIN [@vReferencedTableSchemaName].[vw@vMirrorTablePrefix@vReferencedTableNameCurrent] src
@vNKeyJoinColumnsDML@vIndent;
@vIndentSET @vUpdatedRowCount = @@ROWCOUNT;
@vIndentSET @pUpdateCount = @pUpdateCount + @vUpdatedRowCount;
@vIndentIF	(@vUpdatedRowCount < @vMirrorTableRowCount)
@vIndentBEGIN
@vInferredMemberCreation
@vIndentEND
';
                SELECT	@vReferencedTableHasGeneratedValues				=	t.[HasGeneratedValues]
                ,		@vReferencedTableCanHaveInferredMembersCreated	=	t.[CreateInferredMembers]
                FROM	[codegeneration].[udfDataWarehouseTableMetadata](@vReferencedTableName,@vReferencedTableSchemaName,DEFAULT,DEFAULT)t
                IF (@vReferencedTableCanHaveInferredMembersCreated = 0)
                BEGIN
                        SET	@vInferredMemberCreation = N'@vIndent@vIndent/*No inferred member creation for [@vReferencedTableSchemaName].[@vReferencedTableName]. Decision has been made that inferred members do not get created for this table.*/
@vIndent@vIndentRAISERROR(''[@vTableSchemaName].[@vMirrorTablePrefix@vTableName].[@vColumnName] has %d null values'',16,1,@vNullCount);';
                END
                ELSE IF (@vReferencedTableHasGeneratedValues = 0)
                BEGIN
                        SET	@vInferredMemberCreation = N'@vIndent@vIndent/*No inferred member creation for [@vReferencedTableSchemaName].[@vReferencedTableName]. Inferred members cannot be created for dimension tables that require an explicit value be defined by the surrogate key*/
@vIndent@vIndentRAISERROR(''[@vTableSchemaName].[@vMirrorTablePrefix@vTableName].[@vColumnName] has %d null values'',16,1,@vNullCount);';
                END
                ELSE	/*We are going to create inferred members, where required.*/
                BEGIN
                        SET	@vInferredMemberCreation = N'@vIndent@vIndent/*Create inferred members in [@vReferencedTableSchemaName].[@vReferencedTableName]*/
@vIndent@vIndentINSERT INTO [@vReferencedTableSchemaName].[@vMirrorTablePrefix@vReferencedTableName](
@vInsertColumns2DML@vIndent@vIndent)
@vIndent@vIndentSELECT
@vSelectColumns2DML@vIndent@vIndentFROM [@vReferencedTableSchemaName].[udfTemplate@vReferencedTableName]() t
@vIndent@vIndentCROSS JOIN (	SELECT  @vNKeySelectColumnsDML@vIndent@vIndent				FROM	(
@vIndent@vIndent@vIndent				SELECT	@vNKeySelectColumnsDML@vIndent@vIndent@vIndent				FROM	[@vTableSchemaName].[@vMirrorTablePrefix@vTableName] f
@vIndent@vIndent@vIndent				WHERE	f.[@vColumnName] IS NULL
@vIndent@vIndent@vIndent				GROUP	BY @vNKeySelectColumnsDML@vIndent@vIndent@vIndent) f
@vIndent@vIndent)f
@vIndent@vIndent/*There is a possibility that a concurrent ToMirror sproc has already populated the 
@vIndent@vIndentmirror table with the requisite inferred members. This LEFT OUTER JOIN to the target
@vIndent@vIndentprotects against the same insertion happening twice*/
@vIndent@vIndentLEFT OUTER JOIN [@vReferencedTableSchemaName].[@vMirrorTablePrefix@vReferencedTableName] m
@vIndent@vIndent    @vNKeyJoinColumns2DML@vIndent@vIndentWHERE   m.[@vFirstNKeyJoinColumn] IS NULL
@vIndent@vIndent;
@vIndent@vIndentSET	@vInferredMemberTally = @@ROWCOUNT;
@vIndent@vIndentSET	@vRemark = CONVERT(NVARCHAR(50),@vInferredMemberTally) + N'' inferred members created in [@vReferencedTableSchemaName].[@vMirrorTablePrefix@vReferencedTableName].'';
@vIndent@vIndentEXEC	[$(DATA_WAREHOUSE_DIFRAMEWORK_DATABASE_NAME)].[datawarehouse].[uspPutActivityLog]
@vIndent@vIndent				@pTargetTable	=	N''@vTableName''
@vIndent@vIndent		,		@pPhase			=	@vPhase
@vIndent@vIndent		,		@pStep			=	N''InferredMemberCreation''
@vIndent@vIndent		,		@pRemark		=	@vRemark
@vIndent@vIndent		,		@pLogId			=	@pLogID
@vIndent@vIndent		;
@vIndent@vIndent/*Run the UPDATE again to lookup surrogate keys for newly created inferred members.*/
@vIndent@vIndentUPDATE	tgt
@vIndent@vIndentSET		[@vColumnName] = src.[@vReferencedColumnName]
@vIndent@vIndentFROM	[@vTableSchemaName].[@vMirrorTablePrefix@vTableName] tgt
@vIndent@vIndentINNER JOIN [@vReferencedTableSchemaName].[vw@vMirrorTablePrefix@vReferencedTableNameCurrent] src
@vNKeyJoinColumnsDML@vIndent@vIndent;
@vIndentSET @vUpdatedRowCount = @@ROWCOUNT;
@vIndentSET @pUpdateCount = @pUpdateCount + @vUpdatedRowCount;'


                        SET		@vSelectColumns2DML = N'
';
                        DECLARE	nkeyselectcolumn_cursor CURSOR
                        FOR		SELECT	c_f.[LookupColumnDML]
                                FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vReferencedTableName,@vReferencedTableSchemaName,@vIndent,14,DEFAULT,DEFAULT)c
                                INNER JOIN [codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,DEFAULT,'    ',10,'f',DEFAULT) c_f
                                    ON	c.[ColumnName] = c_f.[ReferencedTableNKeyColumnName]
                                WHERE	c.[IsNaturalKey] = 1
                                    AND c_f.[ColumnName] = @vColumnName;
                        OPEN	nkeyselectcolumn_cursor;
                        FETCH NEXT FROM nkeyselectcolumn_cursor INTO @vSelectColumn2DML;
                        WHILE	@@FETCH_STATUS = 0
                        BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumn2DML = @vSelectColumn2DML + CHAR(13);
				
				SET	@vSelectColumns2DML = @vSelectColumns2DML + @vSelectColumn2DML;
				SET	@vLoopCounter += 1;
                                FETCH NEXT FROM nkeyselectcolumn_cursor INTO @vSelectColumn2DML;
                        END
                        CLOSE	nkeyselectcolumn_cursor;
                        DEALLOCATE nkeyselectcolumn_cursor;
                        SET	@vNKeySelectColumnsDML = @vSelectColumns2DML;
                        /*Get rid of first comma*/
                        SET	@vNKeySelectColumnsDML = STUFF(@vNKeySelectColumnsDML,CHARINDEX(N',',@vNKeySelectColumnsDML,1),1,' ');
                        SET	@vInferredMemberCreation = REPLACE(@vInferredMemberCreation,N'@vNKeySelectColumnsDML',@vNKeySelectColumnsDML);
                        SET @vNKeyJoinColumns2DML = REPLACE(REPLACE(@vNKeyJoinColumnsDML,N'tgt.',N'f.'),N'src.',N'm.');
                        SET	@vInferredMemberCreation = REPLACE(@vInferredMemberCreation,N'@vNKeyJoinColumns2DML',@vNKeyJoinColumns2DML);
                        SET	@vInferredMemberCreation = REPLACE(@vInferredMemberCreation,N'@vFirstNKeyJoinColumn',@vFirstNKeyJoinColumn);
                        
                        SET		@vInsertColumns2DML = N'';
                        SET		@vSelectColumns2DML = N'';
                        /*There are 4 cursors here. Ordinarily there would be 2 cursors, one for the INSERT clause, one for the SELECT clause.
                        In this case though the natural key (NK) columns need to come from the Mirror table and all other attributes come from
                        the template. Hence, for both the INSERT and SELECT clauses we need two cursors, one for the NK columns and one for the 
                        none NK columns. Hence 4 cursors:
                            inferred_member_insert_cursor_NKcols
                            inferred_member_insert_cursor_noneNKcols
                            inferred_member_select_cursor_NKcols
                            inferred_member_select_cursor_noneNKcols
                        */
                        DECLARE	inferred_member_insert_cursor_NKcols CURSOR
                        FOR		SELECT	c.[ColumnDML]
                                FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vReferencedTableName,@vReferencedTableSchemaName,@vIndent,10,DEFAULT,DEFAULT) c
                                WHERE	c.[IsSurrogateKey]	=	0
                                    AND	c.[IsLineage]		=	0
                                    AND	c.[IsNaturalKey]	=	1
                                ORDER	BY c.[column_id] ASC;
                        OPEN	inferred_member_insert_cursor_NKcols;
                        FETCH NEXT FROM inferred_member_insert_cursor_NKcols INTO @vInsertColumn2DML;
                        WHILE	@@FETCH_STATUS = 0
                        BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumn2DML = @vInsertColumn2DML + CHAR(13);
				
				SET	@vInsertColumns2DML = @vInsertColumns2DML + @vInsertColumn2DML;
				SET	@vLoopCounter += 1;
                                FETCH NEXT FROM inferred_member_insert_cursor_NKcols INTO @vInsertColumn2DML;
                        END
                        CLOSE	inferred_member_insert_cursor_NKcols;
                        DEALLOCATE inferred_member_insert_cursor_NKcols;

                        DECLARE	inferred_member_insert_cursor_noneNKcols CURSOR
                        FOR		SELECT	CASE 
											WHEN SUBSTRING(c.ColumnName,1,3) = 'Dim' AND SUBSTRING(c.ColumnName,LEN(c.ColumnName)-3,4) = 'SKey' 
												THEN REPLACE(c.[ColumnDML],c.ColumnName,SUBSTRING(c.ColumnName,4,LEN(c.ColumnName)-7))
											ELSE c.[ColumnDML]
										END -- Workaround so DateSKeys in dimensions that have members inferred use the date column instead.
											-- It's dependent on a naming convention with the field prefixed and suffixed with "Dim" and "SKey" respectively.
                                FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vReferencedTableName,@vReferencedTableSchemaName,@vIndent,10,DEFAULT,DEFAULT) c
                                WHERE	c.[IsSurrogateKey]	=	0
                                    AND	c.[IsLineage]		=	0
                                    AND	c.[IsNaturalKey]	=	0
                                    AND c.[is_computed]     <>  1
                                ORDER	BY c.[column_id] ASC;
                        OPEN	inferred_member_insert_cursor_noneNKcols;
                        FETCH NEXT FROM inferred_member_insert_cursor_noneNKcols INTO @vInsertColumn2DML;
                        WHILE	@@FETCH_STATUS = 0
                        BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumn2DML = @vInsertColumn2DML + CHAR(13);
				
				SET	@vInsertColumns2DML = @vInsertColumns2DML + @vInsertColumn2DML;
				SET	@vLoopCounter += 1;
                                FETCH NEXT FROM inferred_member_insert_cursor_noneNKcols INTO @vInsertColumn2DML;
                        END
                        CLOSE	inferred_member_insert_cursor_noneNKcols;
                        DEALLOCATE inferred_member_insert_cursor_noneNKcols;
                        
                        DECLARE	inferred_member_select_cursor_NKcols CURSOR
                        FOR		SELECT	c_f.[LookupColumnDML]
                                FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vReferencedTableName,@vReferencedTableSchemaName,@vIndent,10,DEFAULT,DEFAULT) c
                                INNER JOIN [codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,10,'f',DEFAULT) c_f
                                    ON	c.[ColumnName] = c_f.[ReferencedTableNKeyColumnName]
                                WHERE	c.[IsSurrogateKey]	=	0
                                    AND	c.[IsLineage]		=	0
                                    AND	c.[IsNaturalKey]	=	1
                                    AND c_f.[ColumnName] = @vColumnName
                                ORDER	BY c.[column_id] ASC;
                        OPEN	inferred_member_select_cursor_NKcols;
                        FETCH NEXT FROM inferred_member_select_cursor_NKcols INTO @vSelectColumn2DML;
                        WHILE	@@FETCH_STATUS = 0
                        BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumn2DML = @vSelectColumn2DML + CHAR(13);
				
				SET	@vSelectColumns2DML = @vSelectColumns2DML + @vSelectColumn2DML;
				SET	@vLoopCounter += 1;
                                FETCH NEXT FROM inferred_member_select_cursor_NKcols INTO @vSelectColumn2DML;
                        END
                        CLOSE	inferred_member_select_cursor_NKcols;
                        DEALLOCATE inferred_member_select_cursor_NKcols;
                        DECLARE	inferred_member_select_cursor_noneNKcols CURSOR
                        FOR		SELECT	CASE 
											WHEN SUBSTRING(c.ColumnName,1,3) = 'Dim' AND SUBSTRING(c.ColumnName,LEN(c.ColumnName)-3,4) = 'SKey' 
												THEN REPLACE(c.[ColumnDML],c.ColumnName,SUBSTRING(c.ColumnName,4,LEN(c.ColumnName)-7))
											ELSE c.[ColumnDML]
										END -- Workaround so DateSKeys in dimensions that have members inferred use the date column instead.
											-- It's dependent on a naming convention with the field prefixed and suffixed with "Dim" and "SKey" respectively.
                                FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vReferencedTableName,@vReferencedTableSchemaName,@vIndent,10,'t',DEFAULT) c
                                WHERE	c.[IsSurrogateKey]	=	0
                                    AND	c.[IsLineage]		=	0
                                    AND	c.[IsNaturalKey]	=	0
                                    AND c.[is_computed]     <>  1
                                ORDER	BY c.[column_id] ASC;
                        OPEN	inferred_member_select_cursor_noneNKcols;
                        FETCH NEXT FROM inferred_member_select_cursor_noneNKcols INTO @vSelectColumn2DML;
                        WHILE	@@FETCH_STATUS = 0
                        BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumn2DML = @vSelectColumn2DML + CHAR(13);
				
				SET	@vSelectColumns2DML = @vSelectColumns2DML + @vSelectColumn2DML;
				SET	@vLoopCounter += 1;
                                FETCH NEXT FROM inferred_member_select_cursor_noneNKcols INTO @vSelectColumn2DML;
                        END
                        CLOSE	inferred_member_select_cursor_noneNKcols;
                        DEALLOCATE inferred_member_select_cursor_noneNKcols;
                        /*PublishType & SCD columns*/
                        SET		@vInsertColumn2DML	=	N'@vIndent@vIndent,[SCDValidFrom]'
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumn2DML = @vInsertColumn2DML + CHAR(13);
				
				SET	@vInsertColumns2DML = @vInsertColumns2DML + @vInsertColumn2DML;
				SET	@vLoopCounter += 1;
                        SET		@vInsertColumn2DML	=	N'@vIndent@vIndent,[SCDValidTo]'
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumn2DML = @vInsertColumn2DML + CHAR(13);
				
				SET	@vInsertColumns2DML = @vInsertColumns2DML + @vInsertColumn2DML;
				SET	@vLoopCounter += 1;
                        SET		@vInsertColumn2DML	=	N'@vIndent@vIndent,[IsCurrent]'
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumn2DML = @vInsertColumn2DML + CHAR(13);
				
				SET	@vInsertColumns2DML = @vInsertColumns2DML + @vInsertColumn2DML;
				SET	@vLoopCounter += 1;
                        SET		@vInsertColumn2DML	=	N'@vIndent@vIndent,[PublishType]'
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumn2DML = @vInsertColumn2DML + CHAR(13);
				
				SET	@vInsertColumns2DML = @vInsertColumns2DML + @vInsertColumn2DML;
				SET	@vLoopCounter += 1;
                        SET		@vSelectColumn2DML	=	N'@vIndent@vIndent,@vSCDTimestamp'	--SCDValidFrom
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumn2DML = @vSelectColumn2DML + CHAR(13);
				
				SET	@vSelectColumns2DML = @vSelectColumns2DML + @vSelectColumn2DML;
				SET	@vLoopCounter += 1;
                        SET		@vSelectColumn2DML	=	N'@vIndent@vIndent,@vSCDEndOfTime'	--SCDValidTo
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumn2DML = @vSelectColumn2DML + CHAR(13);
				
				SET	@vSelectColumns2DML = @vSelectColumns2DML + @vSelectColumn2DML;
				SET	@vLoopCounter += 1;
                        SET		@vSelectColumn2DML	=	N'@vIndent@vIndent,1'				--IsCurrent
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumn2DML = @vSelectColumn2DML + CHAR(13);
				
				SET	@vSelectColumns2DML = @vSelectColumns2DML + @vSelectColumn2DML;
				SET	@vLoopCounter += 1;
                        SET		@vSelectColumn2DML	=	N'@vIndent@vIndent,[PublishType] = @vPublishTypeInsert'
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumn2DML = @vSelectColumn2DML + CHAR(13);
				
				SET	@vSelectColumns2DML = @vSelectColumns2DML + @vSelectColumn2DML;
				SET	@vLoopCounter += 1;
                        /*Get rid of first comma*/
                        SET	@vInsertColumns2DML = STUFF(@vInsertColumns2DML,CHARINDEX(N',',@vInsertColumns2DML,1),1,' ');
                        SET	@vSelectColumns2DML = STUFF(@vSelectColumns2DML,CHARINDEX(N',',@vSelectColumns2DML,1),1,' ');
                        SET	@vInferredMemberCreation = REPLACE(@vInferredMemberCreation,N'@vInsertColumns2DML',@vInsertColumns2DML);
                        SET	@vInferredMemberCreation = REPLACE(@vInferredMemberCreation,N'@vSelectColumns2DML',@vSelectColumns2DML);
                END
                
                SET		@vLookupUpdateQuery = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(@vLookupUpdateQuery,N'@vInferredMemberCreation',@vInferredMemberCreation),N'@vColumnName',@vColumnName),N'@vReferencedColumnName',@vReferencedColumnName),N'@vTableSchemaName',@vTableSchemaName),N'@vTableName',@vTableName),N'@vReferencedTableSchemaName',@vReferencedTableSchemaName),N'@vReferencedTableName',@vReferencedTableName),N'@vNKeyJoinColumnsDML',@vNKeyJoinColumnsDML);
                SET		@vProcedureBody = @vProcedureBody + CHAR(10) + CHAR(10) + @vLookupUpdateQuery;
                FETCH NEXT FROM lookup_cursor INTO @vColumnName,@vReferencedTableName,@vReferencedTableSchemaName,@vReferencedColumnName;--,@vReferencedTableNKeyColumnName,@vLookupColumnName;
        END
        CLOSE	lookup_cursor;
        DEALLOCATE lookup_cursor;
        SET		@vRemark = REPLACE('@vLoopCounter columns built',N'@vLoopCounter',@vLoopCounter);
        EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
                    @pTableSchemaName		=	@vTableSchemaName
                ,	@pTableName				=	@vTableName
                ,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
                ,	@pStep					=	N'Build Columns'
                ,	@pRemark				=	@vRemark;
           

        --SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vNKeyColumnName',			@vNKeyColumnName		);
        SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableSchemaName',			@vTableSchemaName		);
        SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableName',				@vTableName				);
        SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTablePrefix',				@vTablePrefix			);
        SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vMirrorTablePrefix',		@vMirrorTablePrefix		);
        SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTransformTablePrefix',	@vTransformTablePrefix	);
        --SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vViewPrefix',				@vViewPrefix			);
        --SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vViewSuffix',				@vViewSuffix			);
        SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPublishTypeInsert',		@vPublishTypeInsert		);
        SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPublishTypeUpdate',		@vPublishTypeUpdate		);
        SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPublishTypeDelete',		@vPublishTypeDelete		);
        SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vIndent',				REPLICATE(@vIndent,4)	);
        SET		@vSQL	=	REPLACE(@vSQL,[codegeneration].[udfStoredProcedureTemplateBody](),@vProcedureBody)
        EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
                    @pTableSchemaName		=	@vTableSchemaName
                ,	@pTableName				=	@vTableName
                ,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
                ,	@pStep					=	N'Dynamic SQL build complete'
                ,	@pRemark				=	@vSQL;
        
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
        

		END              
		IF (@vGeneratePublishFlag = 1)
		BEGIN
		SET	@vProcedurePrefix =	N'Publish';
		SET	@vTablePrefix =	N'Mirror';
		SET	@vLoopCounter = 0;
		SET	@vProcedureSchemaAndProcedureName = REPLACE(
													REPLACE(
														REPLACE(
															REPLACE(	N'[@vProcedureSchemaName].[@vGlobalProcedurePrefix@vProcedurePrefix@vProcedureName]',
																		N'@vProcedureName',
																		@vTableName
																	),
																	N'@vProcedureSchemaName',
																	@vTableSchemaName
																),
																N'@vProcedurePrefix',
																@vProcedurePrefix
															),
															N'@vGlobalProcedurePrefix',
															@vGlobalProcedurePrefix
														);
		SET	@vObjectToBeGenerated = @vProcedureSchemaAndProcedureName;
		IF (OBJECT_ID(@vProcedureSchemaAndProcedureName) IS NOT NULL)
		BEGIN
				IF	('$(ExecDynamicSQL)' = '1')
				BEGIN
						SET	@vSQL = N'DROP PROCEDURE ' + @vProcedureSchemaAndProcedureName;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
				END
				SET		@vRemark = REPLACE('@vProcedureSchemaAndProcedureName already exists. Drop it!',N'@vProcedureSchemaAndProcedureName',@vProcedureSchemaAndProcedureName);
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;			
		END
		ELSE
		BEGIN
				SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' does not already exist, no need to be DROPped!';
				PRINT	@vRemark;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;
		END
		/*OK, here's where we build our stored procedure*/
		SET		@vSQL	=	REPLACE(REPLACE([codegeneration].[udfStoredProcedureTemplate](),N'BEGIN TRAN;',N''),N'COMMIT TRAN;',N'');
		SET		@vSQL	=	REPLACE(@vSQL,N'@vProcedureSchemaAndProcedureName',	@vProcedureSchemaAndProcedureName);

		SET		@vInsertColumnsDML = N'';
		SET		@vSelectColumnsDML = N'';
		SET		@vUpdateColumnsDML = N'';
		
		DECLARE	column_cursor CURSOR
		FOR		SELECT	c.[ColumnDML],c.[ColumnName]
				FROM	(
						SELECT	c.[column_id],c.[ColumnDML],c.[ColumnName]
						FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,6,DEFAULT,DEFAULT) c
						WHERE	c.[IsLineage] = 0
                            AND c.[is_computed] <> 1
						GROUP	BY c.[column_id],c.[ColumnDML],c.[ColumnName]
						)c
				ORDER	BY c.[column_id] ASC;

		OPEN	column_cursor;
		FETCH NEXT FROM column_cursor INTO @vSelectColumnDML,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				SET	@vInsertColumnDML = @vSelectColumnDML;
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumnDML = @vInsertColumnDML + CHAR(13);
				
				SET	@vInsertColumnsDML = @vInsertColumnsDML + @vInsertColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM column_cursor INTO @vSelectColumnDML,@vColumnName;
		END
		CLOSE	column_cursor;
		DEALLOCATE column_cursor;
		SET		@vInsertColumnDML = N'@vIndent,[@vCreatedByColumnName]';
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumnDML = @vInsertColumnDML + CHAR(13);
				
				SET	@vInsertColumnsDML = @vInsertColumnsDML + @vInsertColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vSelectColumnDML = N'@vIndent,[@vCreatedByColumnName] = @vLineageIDParameterName';
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vInsertColumnDML = N'@vIndent,[@vLastModifiedByColumnName]';
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vInsertColumnDML
				--END
				
				SET	@vInsertColumnDML = @vInsertColumnDML + CHAR(13);
				
				SET	@vInsertColumnsDML = @vInsertColumnsDML + @vInsertColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vSelectColumnDML = N'@vIndent,[@vLastModifiedByColumnName] = @vLineageIDParameterName';
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
		SET		@vRemark = REPLACE('@vLoopCounter columns built',N'@vLoopCounter',@vLoopCounter);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Build Columns'
				,	@pRemark				=	@vRemark;

		DECLARE	update_column_cursor CURSOR
		FOR		SELECT	c.[MergeUpdateSetDML],c.ColumnName
				FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,@vIndent,4,N'src',N'tgt') c
				WHERE	c.[GenerateValue]		=	0
					AND	c.[IsNaturalKey]		=	0
                    AND c.[is_computed]         <>  1
				ORDER	BY c.[column_id] ASC;
		OPEN	update_column_cursor;
		FETCH NEXT FROM update_column_cursor INTO @vUpdateColumnDML,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				SET	@vLoopCounter += 1;
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vUpdateColumnDML
				--END
				
				SET	@vUpdateColumnDML = @vUpdateColumnDML + CHAR(13);
				
				SET	@vUpdateColumnsDML = @vUpdateColumnsDML + @vUpdateColumnDML;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM update_column_cursor INTO @vUpdateColumnDML,@vColumnName;
		END
		CLOSE	update_column_cursor;
		DEALLOCATE update_column_cursor;
		
		/*Get rid of first comma*/
		SET	@vInsertColumnsDML = STUFF(@vInsertColumnsDML,CHARINDEX(N',',@vInsertColumnsDML,1),1,' ');
		SET	@vSelectColumnsDML = STUFF(@vSelectColumnsDML,CHARINDEX(N',',@vSelectColumnsDML,1),1,' ');
		SET	@vUpdateColumnsDML = STUFF(@vUpdateColumnsDML,CHARINDEX(N',',@vUpdateColumnsDML,1),1,' ');

		IF (@vPartitionKeyColumnName IS NOT NULL)
		BEGIN
				SET		@vProcedureBody	=	N'
@vIndentDECLARE	@vPartitionKey	@vPartitionKeyColumnTypeDefinition;
@vIndentDECLARE	@vRemark	NVARCHAR(4000);

@vIndentDELETE FROM [$(DATA_WAREHOUSE_DATABASE_NAME)].[@vTableSchemaName].[@vTableName@vSwitchInSuffix];
@vIndentDELETE FROM [$(DATA_WAREHOUSE_DATABASE_NAME)].[@vTableSchemaName].[@vTableName@vSwitchOutSuffix];
'
		END
		ELSE
		BEGIN
				      SET		@vProcedureBody	=	N'';
		END      

		IF (@vPartitionKeyColumnName IS NOT NULL)
		BEGIN
				SET		@vProcedureBody	=	@vProcedureBody + N'
@vIndent/*INSERTs*/
@vIndentINSERT INTO [$(DATA_WAREHOUSE_DATABASE_NAME)].[@vTableSchemaName].[@vTableName@vSwitchInSuffix] (
@vInsertColumnsDML@vIndent)
@vIndentSELECT
@vSelectColumnsDML@vIndentFROM	[@vTableSchemaName].[@vTablePrefix@vTableName]src;
@vIndentSET		@pInsertCount	=	@@ROWCOUNT;
		';
		END
		ELSE
		BEGIN
				SET		@vProcedureBody	=	@vProcedureBody + N'
@vIndent/*INSERTs*/
@vIndentINSERT INTO [$(DATA_WAREHOUSE_DATABASE_NAME)].[@vTableSchemaName].[@vTableName] (
@vInsertColumnsDML@vIndent)
@vIndentSELECT
@vSelectColumnsDML@vIndentFROM	[@vTableSchemaName].[@vTablePrefix@vTableName]src;
@vIndentSET		@pInsertCount	=	@@ROWCOUNT;
		';
		END

		IF (@vPartitionKeyColumnName IS NOT NULL)
		BEGIN
				SET		@vProcedureBody	=	@vProcedureBody + N'
@vIndentDECLARE	partitionswitch_cursor CURSOR FOR
@vIndent@vIndentSELECT	@vPartitionKeyColumnName
@vIndent@vIndentFROM	[@vTableSchemaName].[@vTablePrefix@vTableName]src
@vIndent@vIndentGROUP	BY @vPartitionKeyColumnName;
@vIndentOPEN	partitionswitch_cursor;
@vIndentFETCH NEXT FROM partitionswitch_cursor INTO @vPartitionKey;
@vIndentWHILE @@FETCH_STATUS = 0
@vIndentBEGIN
@vIndent@vIndentEXEC	[$(DATA_WAREHOUSE_DATABASE_NAME)].[@vTableSchemaName].[uspPartitionSwitchOut@vTableName]
@vIndent@vIndent@vIndent@pPartitionKey	=	@vPartitionKey;
@vIndent@vIndentEXEC	[$(DATA_WAREHOUSE_DATABASE_NAME)].[@vTableSchemaName].[uspPartitionSwitchIn@vTableName]
@vIndent@vIndent@vIndent@pPartitionKey	=	@vPartitionKey;
@vIndent@vIndentFETCH NEXT FROM partitionswitch_cursor INTO @vPartitionKey;
@vIndentEND
@vIndentCLOSE partitionswitch_cursor;
@vIndentDEALLOCATE partitionswitch_cursor;

@vIndent/*[$(DATA_WAREHOUSE_DATABASE_NAME)].[@vTableSchemaName].[@vTableName@vSwitchOutSuffix] could be truncated at this point. 
@vIndent It has been chosen not to do that so that the data is available if required for problem resolution/debugging. It will be 
@vIndenttruncated the next time this sproc executes.*/
'
		END;
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vInsertColumnsDML',					@vInsertColumnsDML							);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vSwitchInSuffix',						@vSwitchInSuffix							);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vSwitchOutSuffix',						@vSwitchOutSuffix							);
		IF	(@vPartitionKeyColumnName IS NOT NULL)
				SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPartitionKeyColumnName',				@vPartitionKeyColumnName			);
		IF	(@vPartitionKeyColumnTypeDefinition IS NOT NULL)
				SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPartitionKeyColumnTypeDefinition',	@vPartitionKeyColumnTypeDefinition	);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vSelectColumnsDML',					@vSelectColumnsDML							);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vUpdateColumnsDML',					@vUpdateColumnsDML							);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableSchemaName',						@vTableSchemaName							);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableName',							@vTableName									);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTablePrefix',							@vTablePrefix								);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPublishTypeInsert',					@vPublishTypeInsert							);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vIndent',								REPLICATE(@vIndent,4)						);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vCreatedByColumnName',					@vCreatedByColumnName						);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vLastModifiedByColumnName',			@vLastModifiedByColumnName					);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vLineageIDParameterName',				@vLineageIDParameterName					);
		SET		@vSQL	=	REPLACE(@vSQL,[codegeneration].[udfStoredProcedureTemplateBody](),@vProcedureBody)
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END

		END              
		FETCH NEXT FROM fact_table_cursor INTO @vTableName,@vTableSchemaName,@vGenerateToTransformFlag,@vPartitionKeyColumnName,@vPartitionKeyColumnTypeDefinition,@vGenerateCopyToMirrorFlag,@vGenerateToMirrorFlag,@vGeneratePublishFlag;;
END

CLOSE	fact_table_cursor;
DEALLOCATE	fact_table_cursor;

/*Degenerate Dimensions*/
DECLARE	degenerate_dimension_cursor CURSOR
FOR		SELECT	c.[ColumnDML],c.ColumnName,c.[UnknownValue],t.[TableSchemaName]
        FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT)c
        INNER JOIN [codegeneration].[udfDataWarehouseTableMetadata](DEFAULT,DEFAULT,'Fact','1')t
            ON  t.[object_id] = c.[object_id]
        WHERE	c.[DegenerateDimension] = 1
        GROUP   BY c.[ColumnDML],c.ColumnName,c.[UnknownValue],t.[TableSchemaName];
OPEN degenerate_dimension_cursor;
FETCH NEXT FROM degenerate_dimension_cursor INTO @vSelectColumnDML,@vColumnName,@vUnknownValue,@vTableSchemaName;
WHILE @@FETCH_STATUS = 0
BEGIN
		SET	@vFunctionPrefix =	N'TemplateDegenerate';
        SET @vTableName = @vColumnName; --Only doing this so that calls to [codegeneration].[uspLogCodeGenerationProgress] still work
		SET	@vFunctionSchemaAndFunctionName = REPLACE(
													REPLACE(
														REPLACE(
															REPLACE(	N'[@vFunctionSchemaName].[@vGlobalFunctionPrefix@vFunctionPrefix@vColumnName]',
																		N'@vColumnName',
																		@vColumnName
																	),
																	N'@vFunctionSchemaName',
																	@vTableSchemaName
																),
																N'@vFunctionPrefix',
																@vFunctionPrefix
															),
															N'@vGlobalFunctionPrefix',
															@vGlobalFunctionPrefix
														);
		SET	@vObjectToBeGenerated = @vFunctionSchemaAndFunctionName;
		IF (OBJECT_ID(@vFunctionSchemaAndFunctionName) IS NOT NULL)
		BEGIN
				IF	('$(ExecDynamicSQL)' = '1')
				BEGIN
						SET	@vSQL = N'DROP FUNCTION ' + @vFunctionSchemaAndFunctionName;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
				END
				SET		@vRemark = REPLACE('@vFunctionSchemaAndFunctionName already exists. Drop it!',N'@vFunctionSchemaAndFunctionName',@vFunctionSchemaAndFunctionName);
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Function'
						,	@pRemark				=	@vRemark;			
		END
		ELSE
		BEGIN
				SET		@vRemark = 'Function ''' + @vFunctionSchemaAndFunctionName + ''' does not already exist, no need to be DROPped!';
				PRINT	@vRemark;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Function'
						,	@pRemark				=	@vRemark;
		END

		/*OK, here's where we build our function*/
        SET     @vSelectColumnsDML = '';
        SET		@vSQL	=	[codegeneration].[udfTemplateFunctionTemplate]();
        SET		@vSQL	=	REPLACE(@vSQL,N'@vFunctionSchemaAndFunctionName',	@vFunctionSchemaAndFunctionName);
        
        SET	@vSelectColumnDML = @vSelectColumnDML + N' = ' + @vUnknownValue
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT	@vSelectColumnDML
				--END
				
				SET	@vSelectColumnDML = @vSelectColumnDML + CHAR(13);
				
				SET	@vSelectColumnsDML = @vSelectColumnsDML + @vSelectColumnDML;
				SET	@vLoopCounter += 1;
        
		/*Get rid of first comma*/
		SET	@vSelectColumnsDML = STUFF(@vSelectColumnsDML,CHARINDEX(N',',@vSelectColumnsDML,1),1,' ');
        
		SET		@vSQL	=	REPLACE(@vSQL,N'@vColumns',@vSelectColumnsDML);
        EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
        
        FETCH NEXT FROM degenerate_dimension_cursor INTO @vSelectColumnDML,@vColumnName,@vUnknownValue,@vTableSchemaName;
END
CLOSE	degenerate_dimension_cursor;
DEALLOCATE	degenerate_dimension_cursor;

/*Presentation Views*/
DECLARE	presentation_view_cursor CURSOR
FOR		SELECT	t.[TableName],t.[TableSchemaName],t.[GenerateToTransformFlag]
		FROM	[codegeneration].[udfDataWarehouseTableMetadata](DEFAULT,DEFAULT,DEFAULT,N'1')t
		WHERE	t.[GeneratePresentationViewFlag] = 1;
		
OPEN presentation_view_cursor;
FETCH NEXT FROM presentation_view_cursor INTO @vTableName,@vTableSchemaName,@vGenerateToTransformFlag;

WHILE @@FETCH_STATUS = 0
BEGIN
		PRINT	REPLACE(REPLACE(N'Generating presentation view for [@vTableSchemaName].[@vTableName]','@vTableSchemaName',@vTableSchemaName),N'@vTableName',@vTableName);
		SET	@vViewPrefix =	@vGlobalViewPrefix;
		SET	@vLoopCounter = 0;
		SET	@vObjectToBeGenerated = N'[@vTableSchemaName].[@vViewPrefix@vTableName]';
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vTableSchemaName',	@vTableSchemaName	);
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vTableName',		@vTableName			);
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vViewPrefix',		@vViewPrefix		);
		SET	@vSQL = N'IF EXISTS (SELECT 1 FROM [$(DATA_WAREHOUSE_DATABASE_NAME)].[sys].[views] WHERE [name] = N''@vViewPrefix@vTableName'' AND SCHEMA_NAME([schema_id]) = N''@vTableSchemaName'') DROP VIEW @vObjectToBeGenerated;' + CHAR(13);
		SET	@vSQL = REPLACE(@vSQL,	N'@vObjectToBeGenerated',	@vObjectToBeGenerated	);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableName',				@vTableName				);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableSchemaName',		@vTableSchemaName		);
		SET	@vSQL = REPLACE(@vSQL,	N'@vViewPrefix',			@vViewPrefix			);
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	[$(DATA_WAREHOUSE_DATABASE_NAME)].dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
		SET	@vSQL = N'CREATE VIEW @vObjectToBeGenerated AS' + CHAR(13) + N'SELECT' + CHAR(13) + N'@vColumnsDDL' + N'FROM [@vTableSchemaName].[@vTableName] ' + CHAR(13);
		SET	@vColumnsDDL = N'';		
		DECLARE	column_cursor CURSOR
		FOR		SELECT	c.[ColumnDML],c.[ColumnName]
				FROM	(
						SELECT	c.[column_id],c.[ColumnDML],c.[ColumnName]
						FROM	[codegeneration].[udfDataWarehouseTableColumnMetadata](@vTableName,@vTableSchemaName,DEFAULT,DEFAULT,DEFAULT,DEFAULT) c
						GROUP	BY c.[column_id],c.[ColumnDML],c.[ColumnName]
				)c
				ORDER	BY c.[column_id] ASC;

		OPEN	column_cursor;
		FETCH NEXT FROM column_cursor INTO @vColumnDDL,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				--IF	($(PrintDynamicSQL) = 1)
				--BEGIN
				--		PRINT	CHAR(13) + @vColumnName;
				--		PRINT	N'===================================';
				--		PRINT @vColumnDDL
				--END
				
				SET	@vColumnDDL = @vColumnDDL + CHAR(13);
				
				SET	@vColumnsDDL = @vColumnsDDL + @vColumnDDL;
				SET	@vLoopCounter += 1;
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM column_cursor INTO @vColumnDDL,@vColumnName;
		END
		CLOSE	column_cursor;
		DEALLOCATE column_cursor;
		SET		@vRemark = REPLACE('@vLoopCounter columns built',N'@vLoopCounter',@vLoopCounter);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Build Columns'
				,	@pRemark				=	@vRemark;

		/*Let's be good T-SQL citizens!*/
		SET	@vSQL = @vSQL + N';';

		/*Get rid of first comma*/
		SET	@vColumnsDDL = STUFF(@vColumnsDDL,CHARINDEX(N',',@vColumnsDDL,1),1,' ');
		
		SET	@vSQL = REPLACE(@vSQL,	N'@vObjectToBeGenerated',	@vObjectToBeGenerated	);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableName',				@vTableName				);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableSchemaName',		@vTableSchemaName		);
		SET	@vSQL = REPLACE(@vSQL,	N'@vViewPrefix',			@vViewPrefix			);
		SET	@vSQL = REPLACE(@vSQL,	N'@vColumnsDDL',			@vColumnsDDL			);
		SET	@vSQL = REPLACE(@vSQL,	N'@vIndent',				@vIndent				);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	[$(DATA_WAREHOUSE_DATABASE_NAME)].dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END

		FETCH NEXT FROM presentation_view_cursor INTO @vTableName,@vTableSchemaName,@vGenerateToTransformFlag;
END

CLOSE	presentation_view_cursor;
DEALLOCATE	presentation_view_cursor;
/*Update Stats sproc*/
DECLARE	update_stats_cursor CURSOR
FOR		SELECT	t.[TableName],t.[TableSchemaName]
		FROM	[codegeneration].[udfDataWarehouseTableMetadata](DEFAULT,DEFAULT,DEFAULT,N'1')t
		WHERE	t.[GenerateUpdateStatsFlag] = 1;
		
OPEN update_stats_cursor;
FETCH NEXT FROM update_stats_cursor INTO @vTableName,@vTableSchemaName;

WHILE @@FETCH_STATUS = 0
BEGIN
		PRINT	REPLACE(REPLACE(N'Generating UPDATE STATISTICS sproc for [@vTableSchemaName].[@vTableName]','@vTableSchemaName',@vTableSchemaName),N'@vTableName',@vTableName);
		--SET	@vViewPrefix =	REPLACE(N'@vGlobalViewPrefixMirror',N'@vGlobalViewPrefix',@vGlobalViewPrefix);
		--SET	@vViewSuffix =	@vGlobalCurrentViewSuffix;
		SET	@vProcedurePrefix =	N'UpdateStatistics';
		SET	@vLoopCounter = 0;
		SET	@vProcedureSchemaAndProcedureName = REPLACE(
													REPLACE(
														REPLACE(
															REPLACE(	N'[@vProcedureSchemaName].[@vGlobalProcedurePrefix@vProcedurePrefix@vProcedureName]',
																		N'@vProcedureName',
																		@vTableName
																	),
																	N'@vProcedureSchemaName',
																	@vTableSchemaName
																),
																N'@vProcedurePrefix',
																@vProcedurePrefix
															),
															N'@vGlobalProcedurePrefix',
															@vGlobalProcedurePrefix
														);
		SET	@vObjectToBeGenerated = @vProcedureSchemaAndProcedureName;
		IF (OBJECT_ID(@vProcedureSchemaAndProcedureName) IS NOT NULL)
		BEGIN
				IF	('$(ExecDynamicSQL)' = '1')
				BEGIN
						SET	@vSQL = N'DROP PROCEDURE ' + @vProcedureSchemaAndProcedureName;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
				END
				SET		@vRemark = REPLACE('@vProcedureSchemaAndProcedureName already exists. Drop it!',N'@vProcedureSchemaAndProcedureName',@vProcedureSchemaAndProcedureName);
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;			
		END
		ELSE
		BEGIN
				SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' does not already exist, no need to be DROPped!';
				PRINT	@vRemark;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;
		END
		


		/*OK, here's where we build our stored procedure*/
		SET		@vSQL	=	[codegeneration].[udfStoredProcedureTemplate]();
		SET		@vSQL	=	REPLACE(@vSQL,N'@vProcedureSchemaAndProcedureName',	@vProcedureSchemaAndProcedureName);
		
		SET		@vProcedureBody	=	N'UPDATE STATISTICS [$(DATA_WAREHOUSE_DATABASE_NAME)].[@vTableSchemaName].[@vTableName];';

		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Pre ProcedureBody Replace'
						,	@pRemark				=	@vProcedureBody;

		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableSchemaName',			@vTableSchemaName		);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableName',				@vTableName				);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vIndent',				REPLICATE(@vIndent,4)	);
		SET		@vSQL	=	REPLACE(@vSQL,[codegeneration].[udfStoredProcedureTemplateBody](),@vProcedureBody)
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vTableName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
        
		FETCH NEXT FROM update_stats_cursor INTO @vTableName,@vTableSchemaName;
END

CLOSE	update_stats_cursor;
DEALLOCATE	update_stats_cursor;

/*Partition splitter*/
DECLARE	partition_key_view_cursor CURSOR
FOR		SELECT	t.[TableSchemaName],t.[PartitionFunctionName],t.[PartitionColumnTypeDefinition]
		FROM	[codegeneration].[udfDataWarehousePartitionedTableMetadata]()t
        GROUP   BY t.[TableSchemaName],t.[PartitionFunctionName],t.[PartitionColumnTypeDefinition];
		
OPEN partition_key_view_cursor;
FETCH NEXT FROM partition_key_view_cursor INTO @vTableSchemaName,@vPartitionFunctionName,@vPartitionKeyColumnTypeDefinition;

WHILE @@FETCH_STATUS = 0
BEGIN
		PRINT	REPLACE(N'Generating partition Key view for partition function[@vPartitionFunctionName]',N'@vPartitionFunctionName',@vPartitionFunctionName);
		SET	@vViewPrefix =	@vGlobalViewPrefix;
		SET	@vLoopCounter = 0;
		SET	@vObjectToBeGenerated = N'[@vTableSchemaName].[@vViewPrefixPartitionKeysFor@vPartitionFunctionName]';
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vTableSchemaName',	            @vTableSchemaName	    );
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vPartitionFunctionName',		@vPartitionFunctionName	);
		SET	@vObjectToBeGenerated = REPLACE(@vObjectToBeGenerated,N'@vViewPrefix',		            @vViewPrefix		    );
		SET	@vSQL = N'IF EXISTS (SELECT 1 FROM [sys].[views] WHERE [name] = N''@vViewPrefixPartitionKeysFor@vPartitionFunctionName'' AND SCHEMA_NAME([schema_id]) = N''@vTableSchemaName'') DROP VIEW @vObjectToBeGenerated;' + CHAR(13);
		SET	@vSQL = REPLACE(@vSQL,	N'@vObjectToBeGenerated',	    @vObjectToBeGenerated	);
		SET	@vSQL = REPLACE(@vSQL,N'@vTableSchemaName',	            @vTableSchemaName	    );
		SET	@vSQL = REPLACE(@vSQL,N'@vPartitionFunctionName',		@vPartitionFunctionName	);
		SET	@vSQL = REPLACE(@vSQL,N'@vViewPrefix',		            @vViewPrefix		    );
        SET @vTableName = @vPartitionFunctionName; --For the purposes of getting logged in the call to PrintAndExecuteDynamicSQLAgainstDataWarehouse.sql. Its crap like this that make me wish I'd built the code-gen stuff in powershell.
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
		SET	@vSQL = N'CREATE VIEW @vObjectToBeGenerated AS' + CHAR(13) + N'SELECT   [PartitionKeyValue]' + CHAR(13) + N'FROM ' + CHAR(13) + N'(@vUnionDefinition)q' + CHAR(13) + N'GROUP BY [PartitionKeyValue]';
        SET @vUnionDefinition = '';
		DECLARE	table_cursor CURSOR
		FOR		SELECT	t.[TableName],t.[ColumnName]
				FROM	[codegeneration].[udfDataWarehousePartitionedTableMetadata]()t
                WHERE   t.[TableSchemaName] = @vTableSchemaName
                    AND t.[PartitionFunctionName] = @vPartitionFunctionName
                GROUP BY t.[TableName],t.[ColumnName];

		OPEN	table_cursor;
		FETCH NEXT FROM table_cursor INTO @vTableName,@vColumnName;
		WHILE	@@FETCH_STATUS = 0
		BEGIN
				SET @vUnionDefinition = @vUnionDefinition + REPLACE(
                                                                REPLACE(
                                                                    REPLACE(    N'UNION SELECT [PartitionKeyValue] = @vColumnName FROM [@vTableSchemaName].[Mirror@vTableName]', 
                                                                                N'@vTableName', 
                                                                                @vTableName), 
                                                                    N'@vTableSchemaName', 
                                                                    @vTableSchemaName), 
                                                                N'@vColumnName', 
                                                                @vColumnName
                                                            ) + CHAR(13);
				SET	@vLoopCounter += 1;
				FETCH NEXT FROM table_cursor INTO @vTableName,@vColumnName;
		END
		CLOSE	table_cursor;
		DEALLOCATE table_cursor;
		SET		@vRemark = REPLACE('@vLoopCounter tables included in UNION',N'@vLoopCounter',@vLoopCounter);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vPartitionFunctionName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Build UNION'
				,	@pRemark				=	@vRemark;

		/*Let's be good T-SQL citizens!*/
		SET	@vSQL = @vSQL + N';';

		/*Get rid of first UNION*/
		SET	@vUnionDefinition = STUFF(@vUnionDefinition,1,6,'');
		
		SET	@vSQL = REPLACE(@vSQL,	N'@vUnionDefinition',	    @vUnionDefinition	    );
		SET	@vSQL = REPLACE(@vSQL,	N'@vObjectToBeGenerated',	@vObjectToBeGenerated	);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableName',				@vTableName				);
		SET	@vSQL = REPLACE(@vSQL,	N'@vTableSchemaName',		@vTableSchemaName		);
		SET	@vSQL = REPLACE(@vSQL,	N'@vViewPrefix',			@vViewPrefix			);
		SET	@vSQL = REPLACE(@vSQL,	N'@vIndent',				@vIndent				);
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vPartitionFunctionName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
        SET @vTableName = @vPartitionFunctionName; --For the purposes of getting logged in the call to PrintAndExecuteDynamicSQLAgainstDataWarehouse.sql. Its nasty hacks like this that make me wish I'd built the code-gen stuff in powershell.
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END

		FETCH NEXT FROM partition_key_view_cursor INTO @vTableSchemaName,@vPartitionFunctionName,@vPartitionKeyColumnTypeDefinition;
END

CLOSE	partition_key_view_cursor;
DEALLOCATE	partition_key_view_cursor;


DECLARE	partition_key_sproc_cursor CURSOR
FOR		SELECT	t.[TableSchemaName],t.[PartitionFunctionName]
		FROM	[codegeneration].[udfDataWarehousePartitionedTableMetadata]()t
        GROUP   BY t.[TableSchemaName],t.[PartitionFunctionName];
		
OPEN partition_key_sproc_cursor;
FETCH NEXT FROM partition_key_sproc_cursor INTO @vTableSchemaName,@vPartitionFunctionName;

WHILE @@FETCH_STATUS = 0
BEGIN
		PRINT	REPLACE(N'Generating partition split sproc for partition function[@vPartitionFunctionName]',N'@vPartitionFunctionName',@vPartitionFunctionName);
		SET	@vProcedurePrefix =	N'Publish';
		SET	@vLoopCounter = 0;
		SET	@vProcedureSchemaAndProcedureName = REPLACE(
													REPLACE(
														REPLACE(
															REPLACE(	N'[@vProcedureSchemaName].[@vGlobalProcedurePrefix@vProcedurePrefix@vProcedureName]',
																		N'@vProcedureName',
																		@vPartitionFunctionName
																	),
																	N'@vProcedureSchemaName',
																	@vTableSchemaName
																),
																N'@vProcedurePrefix',
																@vProcedurePrefix
															),
															N'@vGlobalProcedurePrefix',
															@vGlobalProcedurePrefix
														);
		SET	@vObjectToBeGenerated = @vProcedureSchemaAndProcedureName;
		IF (OBJECT_ID(@vProcedureSchemaAndProcedureName) IS NOT NULL)
		BEGIN
				IF	('$(ExecDynamicSQL)' = '1')
				BEGIN
						SET	@vSQL = N'DROP PROCEDURE ' + @vProcedureSchemaAndProcedureName;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END
				END
				SET		@vRemark = REPLACE('@vProcedureSchemaAndProcedureName already exists. Drop it!',N'@vProcedureSchemaAndProcedureName',@vProcedureSchemaAndProcedureName);
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vPartitionFunctionName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;			
		END
		ELSE
		BEGIN
				SET		@vRemark = 'Stored procedure ''' + @vProcedureSchemaAndProcedureName + ''' does not already exist, no need to be DROPped!';
				PRINT	@vRemark;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vPartitionFunctionName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Drop Procedure'
						,	@pRemark				=	@vRemark;
		END
		/*OK, here's where we build our stored procedure*/
		SET		@vSQL	=	REPLACE(REPLACE([codegeneration].[udfStoredProcedureTemplate](),N'BEGIN TRAN;',N''),N'COMMIT TRAN;',N'');
		SET		@vSQL	=	REPLACE(@vSQL,N'@vProcedureSchemaAndProcedureName',	@vProcedureSchemaAndProcedureName);


		SET		@vProcedureBody	=	N'
@vIndentDECLARE	@vPartitionKey	@vPartitionKeyColumnTypeDefinition;
@vIndentDECLARE	@vPartitionWasSplit	BIT;
@vIndentDECLARE	@vRemark	NVARCHAR(4000);

@vIndentDECLARE	partitionkey_cursor CURSOR FOR
@vIndent@vIndentSELECT	src.[PartitionKeyValue]
@vIndent@vIndentFROM	[@vTableSchemaName].[@vGlobalViewPrefixPartitionKeysFor@vPartitionFunctionName]src
@vIndent@vIndentWHERE NOT EXISTS (
@vIndent@vIndent@vIndentSELECT 1
@vIndent@vIndent@vIndentFROM DataWarehouse.sys.partition_range_values pv
@vIndent@vIndent@vIndent@vIndentINNER JOIN DataWarehouse.sys.partition_functions p
@vIndent@vIndent@vIndent@vIndent@vIndentON pv.function_id = pv.function_id
@vIndent@vIndent@vIndentWHERE p.name = ''@vPartitionFunctionName''
@vIndent@vIndent@vIndent@vIndentAND pv.value IS NOT NULL
@vIndent@vIndent@vIndent@vIndentAND src.[PartitionKeyValue] = pv.value
@vIndent@vIndent)
@vIndent@vIndentORDER   BY src.[PartitionKeyValue] ASC;
@vIndentOPEN	partitionkey_cursor;
@vIndentFETCH NEXT FROM partitionkey_cursor INTO @vPartitionKey;
@vIndentWHILE @@FETCH_STATUS = 0
@vIndentBEGIN
@vIndent@vIndentEXEC	[$(DATA_WAREHOUSE_DATABASE_NAME)].[@vTableSchemaName].[uspPartitionSplit@vPartitionFunctionName]
@vIndent@vIndent@vIndent    @pPartitionKey		=	@vPartitionKey
@vIndent@vIndent@vIndent,   @pPartitionWasSplit	=	@vPartitionWasSplit	OUTPUT;
@vIndent@vIndentIF (@vPartitionWasSplit = 1)
@vIndent@vIndentBEGIN
@vIndent@vIndent@vIndentSET	@vRemark = N''Partition split occurred for partition key='' + CONVERT(NVARCHAR(20),@vPartitionKey);
@vIndent@vIndent@vIndentEXEC	[$(DATA_WAREHOUSE_DIFRAMEWORK_DATABASE_NAME)].[datawarehouse].[uspPutActivityLog]
@vIndent@vIndent@vIndent				@pTargetTable	=	N''@vPartitionFunctionName''
@vIndent@vIndent@vIndent		,		@pPhase			=	@vPhase
@vIndent@vIndent@vIndent		,		@pStep			=	N''PartitionSplit''
@vIndent@vIndent@vIndent		,		@pRemark		=	@vRemark
@vIndent@vIndent@vIndent		,		@pLogId			=	@pLogID
@vIndent@vIndent@vIndent		;
@vIndent@vIndentEND
@vIndent@vIndentELSE
@vIndent@vIndentBEGIN
@vIndent@vIndent@vIndentSET	@vRemark = N''No partition split required for partition key='' + CONVERT(NVARCHAR(20),@vPartitionKey);
@vIndent@vIndent@vIndentEXEC	[$(DATA_WAREHOUSE_DIFRAMEWORK_DATABASE_NAME)].[datawarehouse].[uspPutActivityLog]
@vIndent@vIndent@vIndent				@pTargetTable	=	N''@vPartitionFunctionName''
@vIndent@vIndent@vIndent		,		@pPhase			=	@vPhase
@vIndent@vIndent@vIndent		,		@pStep			=	N''PartitionSplit''
@vIndent@vIndent@vIndent		,		@pRemark		=	@vRemark
@vIndent@vIndent@vIndent		,		@pLogId			=	@pLogID
@vIndent@vIndent@vIndent		;
@vIndent@vIndentEND
@vIndent@vIndentFETCH NEXT FROM partitionkey_cursor INTO @vPartitionKey;
@vIndentEND
@vIndentCLOSE partitionkey_cursor;
@vIndentDEALLOCATE partitionkey_cursor;
';

		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPartitionKeyColumnTypeDefinition',	@vPartitionKeyColumnTypeDefinition			);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableSchemaName',						@vTableSchemaName							);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vTableName',							@vTableName									);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vIndent',								REPLICATE(@vIndent,4)						);
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vPartitionFunctionName',				@vPartitionFunctionName					    );
		SET		@vProcedureBody = REPLACE(@vProcedureBody,N'@vGlobalViewPrefix',				    @vGlobalViewPrefix					        );
        SET		@vSQL	=	REPLACE(@vSQL,[codegeneration].[udfStoredProcedureTemplateBody](),@vProcedureBody)
		EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
					@pTableSchemaName		=	@vTableSchemaName
				,	@pTableName				=	@vPartitionFunctionName
				,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
				,	@pStep					=	N'Dynamic SQL build complete'
				,	@pRemark				=	@vSQL;
		IF	('$(PrintDynamicSQL)' = '1')
				PRINT CHAR(13) + @vSQL;
		IF	('$(ExecDynamicSQL)' = '1')
		BEGIN
				--PRINT	REPLACE(REPLACE(REPLACE(N'Creating table [@vTableSchemaName].[@vTablePrefix@vTableName] (Dropping it if it already exists)',N'@vTableSchemaName',@vTableSchemaName),N'@vTablePrefix',@vTablePrefix),N'@vTableName',@vTableName);
				EXEC	dbo.sp_executesql  @vSQL;
				EXEC	[codegeneration].[uspLogCodeGenerationProgress] 
							@pTableSchemaName		=	@vTableSchemaName
						,	@pTableName				=	@vTableName
						,	@pObjectToBeGenerated	=	@vObjectToBeGenerated
						,	@pStep					=	N'Dynamic SQL execution'
						,	@pRemark				=	@vSQL;
		END

		FETCH NEXT FROM partition_key_sproc_cursor INTO @vTableSchemaName,@vPartitionFunctionName;
END

CLOSE	partition_key_sproc_cursor;
DEALLOCATE	partition_key_sproc_cursor;
SET	@vCodeGenerationEndTime	=	SYSDATETIME()
PRINT	REPLACE(N'Code generation ended at @vCodeGenerationEndTime',N'@vCodeGenerationEndTime',@vCodeGenerationEndTime) + 
		REPLACE(N'. Time taken: #DIFF#seconds',N'#DIFF#',CONVERT(NVARCHAR(100),DATEDIFF(ss,@vCodeGenerationStartTime,@vCodeGenerationEndTime)));

GO

GO
PRINT N'Update complete.';


GO
